<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Paradise of Web</title>
  
  <subtitle>不会弹吉他的贝斯手，不是好程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-13T02:07:33.270Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tian Xueweii</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node环境搭建</title>
    <link href="http://yoursite.com/2018/08/13/Node%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/08/13/Node环境搭建/</id>
    <published>2018-08-13T01:50:58.000Z</published>
    <updated>2018-08-13T02:07:33.270Z</updated>
    
    <content type="html"><![CDATA[<p>由于Node.js版本更新快，版本差异性大，推荐使用3m来管理配置环境</p><ul><li>nvm(Node.js Version Manager)：解决多版本共存、切换问题</li><li>npm(Node.js Package Manager)：解决Node.js模块安装问题，其本身也是一个Node.js 模块</li><li>nrm(Node.js Registry Manager)：解决npm镜像访问慢的问题，提供测速，切换registry功能</li></ul><h2 id="NVM"><a href="#NVM" class="headerlink" title="NVM"></a>NVM</h2><p>Node.js版本变化较大，建议使用nvm进行node版本管理</p><h3 id="nvm安装命令"><a href="#nvm安装命令" class="headerlink" title="nvm安装命令"></a>nvm安装命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash</span><br></pre></td></tr></table></figure><p>通过curl下载install.sh脚本并执行，待执行完成后，它会把nvm命令的执行路径放到~/.bashrc文件里，通过执行source命令，使环境变量生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="nvm的常用命令"><a href="#nvm的常用命令" class="headerlink" title="nvm的常用命令"></a>nvm的常用命令</h3><ul><li>安装：<code>$ nvm install 4.4.5</code></li><li>设置默认：<code>$ nvm alias default 4.4.5</code></li><li>切换版本：<code>$ nvm use 6</code></li><li>列出当前本地版本：<code>$ nvm ls</code></li><li>列出远端可安装版本：<code>$ nvm ls-remote</code></li></ul><p>可以说这5个命令在开发过程中足够用，其实nvm还有很多高级特性，比如在项目根目录创建.npmrc指定特定的Node.js版本，它就切换到对应版本，类似的很多，就不一一列举了</p><h2 id="NRM"><a href="#NRM" class="headerlink" title="NRM"></a>NRM</h2><p>仓库源管理工具，源类似于pods的repo管理。<br>cnpm源每5分钟更新一次，如果上传了新的package使用cnpm不能马上获取更新</p><h3 id="nrm安装命令"><a href="#nrm安装命令" class="headerlink" title="nrm安装命令"></a>nrm安装命令</h3><p>nrm是Node.js的模块，可直接使用npm来安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install --global nrm</span><br></pre></td></tr></table></figure><h3 id="nrm的常用命令"><a href="#nrm的常用命令" class="headerlink" title="nrm的常用命令"></a>nrm的常用命令</h3><ul><li>测速：<code>$ nrm test</code></li><li>查看源：<code>$ nrm ls</code></li><li>切换源：<code>$ nrm use cnpm</code></li></ul><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>当安装好Node.js环境后，就已经自带了npm管理工具</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于Node.js版本更新快，版本差异性大，推荐使用3m来管理配置环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nvm(Node.js Version Manager)：解决多版本共存、切换问题&lt;/li&gt;
&lt;li&gt;npm(Node.js Package Manager)：解决Node.j
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>iOS架构补完计划</title>
    <link href="http://yoursite.com/2018/08/12/iOS%E6%9E%B6%E6%9E%84%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2018/08/12/iOS架构补完计划/</id>
    <published>2018-08-12T12:12:28.000Z</published>
    <updated>2018-08-13T03:11:06.385Z</updated>
    
    <content type="html"><![CDATA[<p>移动端架构上的设计，本质上都是三个角色：数据结构、数据流管理、数据展示。</p><p>不管是MVC、MVVM、MVP、VIPER或者任何新的设计模式、都跳不出这三个角色。无非是把数据管理者的工作进行拆分、唯一的界定标准就是把工作拆分的粒度大小。<br>而无论哪种思想、最终都逃不开三个问题的《《取舍》》。代码量、通用性、可读性。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC就是典型的着重通用型与可读性、这正是一个作为万物之初的架构所需要保证的事。简单、易学。</p><h3 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h3><ul><li>Model：数据结构，数据映射</li><li>View：数据展示</li><li>Controller：负责根据需求对Model及View间的数据流调配</li></ul><h3 id="Controller的瘦身"><a href="#Controller的瘦身" class="headerlink" title="Controller的瘦身"></a>Controller的瘦身</h3><p>不过和广义的MVC不同，iOS端由于UIViewController自带一个容器View。所以除了上述的正统任务之外，Controller还需要承担View的生成，布局等的任务。Controller实际上是Controller+View的一个角色，这样的设定也导致了C层过于臃肿的问题</p><ul><li><p>胖Model</p><p>  主旨是Controller从Model里拿到的数据、不需要进行更多的判断、处理等操作、就能使用。缺点是移植困难、复用困难</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Json Data:</span><br><span class="line">timestamp:1234567</span><br><span class="line"></span><br><span class="line">FatModel:</span><br><span class="line">@property (nonatomic, assign) CGFloat timestamp;</span><br><span class="line">- (NSString *)ymdDateString; // 2015-04-20 15:16</span><br><span class="line">- (NSString *)standardString; // 3分钟前、1小时前、一天前</span><br><span class="line"></span><br><span class="line">Controller:</span><br><span class="line">self.dateLabel.text = [FatModelIns ymdDateString];</span><br><span class="line">self.gapLabel.text = [FatModelIns standardString];</span><br></pre></td></tr></table></figure></li><li><p>瘦Model</p><p>  就是要把MVC的M贯彻倒底、除了业务的表达啥都不管。所以瘦Model要借助一些外来的辅助模块（索性可以叫Helper、Util）来对弱业务做抽象。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Json Data:</span><br><span class="line">&#123;</span><br><span class="line">   &quot;name&quot;:&quot;casa&quot;,</span><br><span class="line">   &quot;sex&quot;:&quot;male&quot;,</span><br><span class="line">&#125;</span><br><span class="line">SlimModel:</span><br><span class="line">   @property (nonatomic, strong) NSString *name;</span><br><span class="line">   @property (nonatomic, strong) NSString *sex;</span><br><span class="line">Util:</span><br><span class="line">   #define Male 1;</span><br><span class="line">   #define Female 0;</span><br><span class="line">   + (BOOL)sexWithString:(NSString *)sex;</span><br><span class="line">Controller:</span><br><span class="line">   if ([Helper sexWithString:SlimModel.sex] == Male) &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>总结：虽然胖瘦Model都一定程度上尝试解决Controller过于臃肿的问题，但是仅仅停留在数据处理、格式化层面，真正的业务逻辑、交互逻辑依然存放于Controller中</p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>本质上与MVVM没有区别，只是将Controller中关于Model和数据处理的代码移植到Presenter中，但是MVP并不是一个完全剥离业务逻辑的设计模式</p><h3 id="架构模型-1"><a href="#架构模型-1" class="headerlink" title="架构模型"></a>架构模型</h3><ul><li><p>View</p><p>  负责界面结构和布局管理，通过Presenter暴露的数据更新和数据获取的接口进行展示</p></li><li><p>Presenter</p><p>  负责处理数据，并提供刷新反馈接口，并管理Model。</p></li><li><p>Model</p><p>  和MVC中的一样，提供数据模型和映射</p></li></ul><p><img src="/2018/08/12/iOS架构补完计划/mvp.jpg" alt=""></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM起源于前端，这种抽离模型响应式架构在Web开发及小程序开发中已经十分普及，在大厂甚至成为一种标准存在。MVVM的出现，为移动端开发Controller/Activity的瘦身带来启发，刚才讲到的胖Model只从Controller中移植了一些简单的弱业务，而大量的交互逻辑仍存放在Controller中</p><h3 id="MVVM力求解决的开发痛点"><a href="#MVVM力求解决的开发痛点" class="headerlink" title="MVVM力求解决的开发痛点"></a>MVVM力求解决的开发痛点</h3><ul><li>过长的数据响应链，每次数据更新都要向上层传递</li><li>控制器层代码臃肿。由于UIKit框架的设计原因，UIViewController承担了过多不应承担的责任，Controller内包含了数据、界面、逻辑元素，只能通过规范约束，难以管理</li><li>架构层面结构划分不清晰，增加了移动端的学习难度</li></ul><h3 id="架构模型-2"><a href="#架构模型-2" class="headerlink" title="架构模型"></a>架构模型</h3><ul><li><p>Model</p><p>  和MVC中的瘦Model一样。只承载最基本的数据单元和数据映射。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface UserModel: NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *userName;</span><br><span class="line">@property (nonatomic, copy) NSString *sex;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>View</p><p>  View层包含了UIKit框架下，UIView和UIViewController及其子类。在View层中只需要编写页面展示模板和数据绑定，不写任何业务逻辑。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">   [super awakeFromNib];</span><br><span class="line">   RAC(self.userNameLabel, text) = RACObserve(self, viewModel.userName);</span><br><span class="line">   RAC(self.userSexLabel, text) = RACObserve(self, viewModel.sex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ViewModel</p><p>  ViewModel里涵盖了所有View层绑定需要的数据模型、逻辑函数、事件响应函数。当数据发生改变，View层会响应式渲染更新界面。</p></li></ul><h3 id="RAC对于MVVM的意义"><a href="#RAC对于MVVM的意义" class="headerlink" title="RAC对于MVVM的意义"></a>RAC对于MVVM的意义</h3><p>RAC(ReactiveCocoa)并不是MVVM思想的核心，不用RAC也能使用MVVM。但是使用RAC能更好的体现MVVM的精髓，即数据绑定处理、响应式渲染。就像Web开发中，使用React、Vue那样。在MVC中，M和V若无持有关系，在数据传递和渲染时会造成很多麻烦，那么如何把原本松散的两者通过中间层联系起来（数据绑定），在iOS本身并没有太靠谱的办法，在Vue中有<code></code>这种优雅的写法。</p><p>虽然KVO、Notification、block、delegate和target-action都可以用来做数据通信进而实现绑定，但都不如RAC来的《《优雅》》。</p><h2 id="关于架构设计的一些观点"><a href="#关于架构设计的一些观点" class="headerlink" title="关于架构设计的一些观点"></a>关于架构设计的一些观点</h2><ul><li><p>控制好Controller的代码量</p><p>  随着项目的进行、代码量最多只能优化、膨胀不可避免。而在没办法继续精简的前提下、想控制Controller的代码量。就要在可读性和通用性之间进行取舍。该挪走的时候就挪走吧、毕竟梳理一个单独的模块、比梳理一个几千行的Controller要方便多了。</p></li><li><p>对于MVX如何选择</p><ul><li>其实完全要看业务性质以及项目复杂度</li><li>如果你一个页面只有一个UITableView，搞出一些奇淫技巧其实意义不大，徒增烦恼。踏踏实实用MVC对大家都好。</li><li>如果业务中View存在多种样式风格，底层数据处理存在大量复用的情况，可以使用MVP</li><li>如果业务相当的复杂，耦合让人浑身难受。做好模块化或者干脆VIPER才是出路。</li><li>如果你追求如前端MVVM框架（Vue、React）一般的开发体验，可以尝试使用RAC，但不建议单独脱离RAC使用MVVM架构</li></ul></li><li><p>无论用哪种模式、都要深刻的理解每个模块不同的职责</p></li></ul><p>ps: 本文基于CocoaChina博主kirito_song的文章，并整理了近期项目实践撰写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;移动端架构上的设计，本质上都是三个角色：数据结构、数据流管理、数据展示。&lt;/p&gt;
&lt;p&gt;不管是MVC、MVVM、MVP、VIPER或者任何新的设计模式、都跳不出这三个角色。无非是把数据管理者的工作进行拆分、唯一的界定标准就是把工作拆分的粒度大小。&lt;br&gt;而无论哪种思想、最终
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>实现虾米音乐首页视差滚动特效</title>
    <link href="http://yoursite.com/2018/07/20/%E5%AE%9E%E7%8E%B0%E8%99%BE%E7%B1%B3%E9%9F%B3%E4%B9%90%E9%A6%96%E9%A1%B5%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8%E7%89%B9%E6%95%88/"/>
    <id>http://yoursite.com/2018/07/20/实现虾米音乐首页视差滚动特效/</id>
    <published>2018-07-20T11:30:28.000Z</published>
    <updated>2018-08-13T01:51:53.996Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目迭代了一个新的版本，由于我们的设计师是虾米音乐的忠实粉丝，首页借鉴了虾米8.0首页的视差动画，在预研实现过程中有一些值得记录和分享的地方</p><h2 id="虾米音乐8-0首页鉴赏"><a href="#虾米音乐8-0首页鉴赏" class="headerlink" title="虾米音乐8.0首页鉴赏"></a>虾米音乐8.0首页鉴赏</h2><p>先看看虾米首页最终的展示效果，搜索栏会随着内容视图滚动偏移渐隐，内容视图有一个视差滚动的效果，达到滚动阈值后搜索栏会隐藏。</p><p>细心的同学可能会发现，Banner与导航栏滚动的速度相同，所以实现的难点，是如何实现Banner图与导航栏的相对静止，同时在表视图滚动到既定偏移量时，Banner图被表视图遮盖的效果。</p><p><img src="/2018/07/20/实现虾米音乐首页视差滚动特效/xiamiHomePage.gif" alt=""></p><h2 id="页面结构分析"><a href="#页面结构分析" class="headerlink" title="页面结构分析"></a>页面结构分析</h2><p>从呈现结果来看，整个视图可以分为两个部分，导航视图（CusNavigationView）及内容视图（MainContentView）。</p><p>导航视图同时包含了一个自定义搜索栏（SearchBar），自定义二级导航栏（NavigationBarLevel2），这个二级导航栏的实现我会单独写一篇博客来讲。</p><p>内容视图是一个表视图（TableView），以及使用表视图的头视图来添加轮播图（BannerView）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┏ CusNavigationView</span><br><span class="line">┃┣ SearchBar</span><br><span class="line">┃┗ NavigationBarLevel2</span><br><span class="line">┗ MainContentView</span><br><span class="line">┣ BannerView</span><br><span class="line">┗ TableView</span><br></pre></td></tr></table></figure><p>此处导航视图为了更好监听MainContentView的滚动偏移对子视图进行控制，没有使用系统的NavigationBar，而采用了自定义的方式。</p><h2 id="让我们实现她！"><a href="#让我们实现她！" class="headerlink" title="让我们实现她！"></a>让我们实现她！</h2><p>在开始编写逻辑前，先根据上个Section分析的视图结构，声明相关视图属性及导航栏折叠前高度与折叠后高度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define ZMC_Fold_Height 44//折叠后高度</span><br><span class="line">#define ZMC_Unfold_Height 94 //折叠前高度</span><br><span class="line">#define ZMC_Fold_Height_Offset (ZMC_Unfold_Height - ZMC_Fold_Height)</span><br><span class="line"></span><br><span class="line">//Navi</span><br><span class="line">@property (nonatomic, strong) UIView *cusNavigationView;</span><br><span class="line">@property (nonatomic, strong) UIView *searchBarView;</span><br><span class="line">@property (nonatomic, strong) UIView *segmentBarView;</span><br><span class="line"></span><br><span class="line">//Table</span><br><span class="line">@property (nonatomic, strong) UITableView *contentTableView;</span><br><span class="line">@property (nonatomic, strong) UIView *bannerView;</span><br></pre></td></tr></table></figure><p>首先先实现视差滚动效果，我们通过实现ScrollView代理，监听滚动事件，通过计算折叠动画内滚动进度比的方式，控制各个视图的相关属性，达到视差效果，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123;</span><br><span class="line">    </span><br><span class="line">    CGFloat offsetY = self.contentTableView.contentOffset.y + ZMC_Fold_Height_Offset;</span><br><span class="line">    CGFloat ratio = offsetY / ZMC_Fold_Height_Offset;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //如果有banner头视图</span><br><span class="line">    if ([self.contentTableView.tableHeaderView isEqual:self.bannerView]) &#123;</span><br><span class="line">        //表格视图需要移动banner.height + ZMC_Fold_Height_Offset</span><br><span class="line">        //banner和navi相对静止</span><br><span class="line">        //移动比为 ZMC_Fold_Height_Offset / banner.height + ZMC_Fold_Height_Offset</span><br><span class="line">        ratio = offsetY / (self.bannerView.frame.size.height + ZMC_Fold_Height_Offset);</span><br><span class="line">        [_contentTableView sendSubviewToBack:self.bannerView];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (ratio &gt; 0 &amp;&amp; ratio &lt; 1) &#123;</span><br><span class="line">        [self.cusNavigationView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.height.mas_equalTo(ZMC_Unfold_Height - ZMC_Fold_Height_Offset * ratio);</span><br><span class="line">        &#125;];</span><br><span class="line">        [self.searchBarView setAlpha:1 - ratio];</span><br><span class="line">        </span><br><span class="line">        if ([self.contentTableView.tableHeaderView isEqual:self.bannerView]) &#123;</span><br><span class="line">            [_banner mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                make.top.mas_equalTo(ratio * self.bannerView.frame.size.height + 20);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (ratio &lt;= 0) &#123;</span><br><span class="line">        [self.cusNavigationView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.height.mas_equalTo(ZMC_Unfold_Height);</span><br><span class="line">        &#125;];</span><br><span class="line">        [self.searchBarView setAlpha:1];</span><br><span class="line">        </span><br><span class="line">        if ([self.contentTableView.tableHeaderView isEqual:self.bannerView]) &#123;</span><br><span class="line">            [_banner mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                make.top.mas_equalTo(20);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (ratio &gt;= 1) &#123;</span><br><span class="line">        [self.cusNavigationView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.height.mas_equalTo(ZMC_Fold_Height);</span><br><span class="line">        &#125;];</span><br><span class="line">        [self.searchBarView setAlpha:0];</span><br><span class="line">        </span><br><span class="line">        if ([self.contentTableView.tableHeaderView isEqual:self.bannerView]) &#123;</span><br><span class="line">            [_banner mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                make.top.mas_equalTo(self.bannerView.frame.size.height + 20);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光实现了视差滚动还不够，如果滚动到一半位置会出现半遮半掩的效果，非常影响体验，于是我们新建一个名为<code>magneticScrollView:</code>的方法，用于控制在结束滚动时进行视图检查，如果进度比在0~1之间，则根据既定阈值调整视图位置，达到弹性效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)magneticScrollView:(UIScrollView *)sc&#123;</span><br><span class="line">    CGFloat offsetY = self.contentTableView.contentOffset.y + ZMC_Fold_Height_Offset;</span><br><span class="line">    CGFloat ratio = offsetY / ZMC_Fold_Height_Offset;</span><br><span class="line">    </span><br><span class="line">    //如果有banner头视图</span><br><span class="line">    if ([self.contentTableView.tableHeaderView isEqual:self.bannerView]) &#123;</span><br><span class="line">        //表格视图需要移动banner.height + ZMC_Fold_Height_Offset</span><br><span class="line">        //banner和navi相对静止</span><br><span class="line">        //移动比为 ZMC_Fold_Height_Offset / banner.height + ZMC_Fold_Height_Offset</span><br><span class="line">        ratio = offsetY / (self.bannerView.frame.size.height + ZMC_Fold_Height_Offset);</span><br><span class="line">        [_contentTableView sendSubviewToBack:self.bannerView];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (ratio &gt; 1 || ratio &lt; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ratio &lt;= 0.5) &#123;</span><br><span class="line">        [sc setContentOffset:CGPointMake(0, -ZMC_Fold_Height_Offset) animated:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    if (ratio &gt; 0.5 &amp;&amp; ratio &lt;= 1) &#123;</span><br><span class="line">        [sc setContentOffset:CGPointMake(0, [self.contentTableView.tableHeaderView isEqual:self.bannerView] ? self.bannerView.frame.size.height : 0) animated:YES];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法如果在滚动视图存在减速的情况下，则在减速完成后调用，若不存在减速，则直接调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123;</span><br><span class="line">    if (!decelerate) &#123;</span><br><span class="line">        [self magneticScrollView:scrollView];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123;</span><br><span class="line">    [self magneticScrollView:scrollView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，虾米8.0首页一个视差效果简单的demo就完成了，核心代码的代码量不到100行。当然，实际的业务需求肯定没有这么简单，重要的是一种实现思路</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目迭代了一个新的版本，由于我们的设计师是虾米音乐的忠实粉丝，首页借鉴了虾米8.0首页的视差动画，在预研实现过程中有一些值得记录和分享的地方&lt;/p&gt;
&lt;h2 id=&quot;虾米音乐8-0首页鉴赏&quot;&gt;&lt;a href=&quot;#虾米音乐8-0首页鉴赏&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UINavigationBar定制的正确姿势</title>
    <link href="http://yoursite.com/2018/07/15/UINavigationBar%E5%AE%9A%E5%88%B6%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/2018/07/15/UINavigationBar定制的正确姿势/</id>
    <published>2018-07-15T12:50:58.000Z</published>
    <updated>2018-08-13T01:51:31.021Z</updated>
    
    <content type="html"><![CDATA[<p>系统导航栏（UINavigationBar）的定制一直以来都是一个比较棘手的问题，特别在iOS11以后导航栏视图结构发生了改变，导致之前很多解决方案都不再适用。由于导航栏图层独立于控制器视图，所以你可以隐藏掉导航栏使用自己绘制的导航栏仅使用导航控制器的视图栈，但本文不推荐这种方式。</p><p>本文采用的方式依然在系统导航栏的基础上进行配置。这么做的好处有很多，首先系统导航栏视图层独立于控制器视图，控制器视图加载于UINavigationTransitionView，导航栏的UINavigationBar与它是平级关系，多数情况下我们是复用它的。其次不用去自己管理复杂的视图层级关系以及滚动视图的调整行为。</p><p>导航控制器的层级关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UITransitionView</span><br><span class="line">┗ UILayoutContainerView</span><br><span class="line">┣ UINavigationTransitionView (控制器视图绘制在这个层级)</span><br><span class="line">┗ UINavigationBar</span><br></pre></td></tr></table></figure><p>导航栏的定制化可分为导航栏渲染配置、以及导航栏控件配置两个部分</p><h2 id="不同版本系统导航栏视图结构"><a href="#不同版本系统导航栏视图结构" class="headerlink" title="不同版本系统导航栏视图结构"></a>不同版本系统导航栏视图结构</h2><p>首先我们来分析一下iOS11前后导航栏（UINavigationBar）的视图结构</p><p>iOS11以前:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UINavigationBar</span><br><span class="line">┣ _UINavigationBarBackground</span><br><span class="line">┃┗ UIImageView (阴影视图)</span><br><span class="line">┣ UILabel (自定义头视图，可为任意类型)</span><br><span class="line">┣ UINavigationItemView </span><br><span class="line">┣ ...</span><br><span class="line">┗ _UINavigationBarBackIndicatorView</span><br></pre></td></tr></table></figure><p>iOS11:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UINavigationBar</span><br><span class="line">┣ _UIBarBackground</span><br><span class="line">┃┣ UIImageView (背景视图)</span><br><span class="line">┃┗ UIImageView (阴影视图)</span><br><span class="line">┗ _UINavigationBarContentView</span><br><span class="line">┣ UILabel (自定义头视图，可为任意类型)</span><br><span class="line">┣ _UIButtonBarStackView</span><br><span class="line">┃┣ _UITAMICAdaptorView</span><br><span class="line">┃┗ ...</span><br><span class="line">┗ ...</span><br></pre></td></tr></table></figure><h2 id="定制导航栏"><a href="#定制导航栏" class="headerlink" title="定制导航栏"></a>定制导航栏</h2><h3 id="UINavigationBarBackground-gt-UIBarBackground"><a href="#UINavigationBarBackground-gt-UIBarBackground" class="headerlink" title="_UINavigationBarBackground -&gt; _UIBarBackground"></a>_UINavigationBarBackground -&gt; _UIBarBackground</h3><p>通过对比，iOS11在导航栏视图上将层级更加细分。iOS11之后多了一层_UIBarBackground视图，背景图及阴影视图位于一个层级。iOS11之前设置背景图，使用<code>setBackgroundImage:forBarMetrics:</code>方法会直接作用在_UINavigationBarBackground上，iOS11之后会在_UIBarBackground下添加一个新的背景视图。但是使用<code>setBarTintColor:</code>方法，依然会着色于父层级。</p><p>通过查看系统API得知，<code>barTintColor</code>属性默认为nil，如果想要改变导航栏背景图和阴影图，我们只需要通过<code>setBackgroundImage:forBarMetrics:</code>和<code>setShadowImage:</code>两个方法即可，po上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//设置导航栏背景视图</span><br><span class="line">[__navigationBar setBackgroundImage:[UIImage imageWithColor:App_Background_Color] forBarMetrics:UIBarMetricsDefault];</span><br><span class="line">//去除下阴影线</span><br><span class="line">[__navigationBar setShadowImage:[UIImage imageWithColor:[UIColor clearColor] size:CGSizeMake(_ScreenWidth, 0.1)]];</span><br><span class="line">//渲染图标</span><br><span class="line">[__navigationBar setTintColor:App_NaviBar_Tint_Color];</span><br><span class="line">//设置标题样式</span><br><span class="line">[__navigationBar setTitleTextAttributes:@&#123;</span><br><span class="line">    NSForegroundColorAttributeName : App_NaviBar_Tint_Color,</span><br><span class="line">    NSFontAttributeName : App_NaviBar_Text_Font</span><br><span class="line">&#125;];</span><br><span class="line">//设置不透明</span><br><span class="line">[__navigationBar setTranslucent:NO];</span><br></pre></td></tr></table></figure><p>ps:设置想要阴影线透明，在使用<code>setShadowImage:</code>方法时，可以设置高度为0.1，若为0则有可能不生效</p><h3 id="UINavigationItemView-gt-UINavigationBarContentView"><a href="#UINavigationItemView-gt-UINavigationBarContentView" class="headerlink" title="UINavigationItemView -&gt; _UINavigationBarContentView"></a>UINavigationItemView -&gt; _UINavigationBarContentView</h3><p>内容视图的变化是导致之前设置样式失效的最大原因，iOS11所有的UIBarButtonItem都是加载到新的_UIButtonBarStackView上的，而_UIButtonBarStackView默认在5.5英寸机型有20px其余机型为16px的边距，UIBarButtonSystemItemFixedSpace也无法使用了。非常幸运，通过不断的尝试，找到了同时完美兼容多系统版本的定制化方案。UIBarButtonItem的<code>initWithCustomView:</code>方法，为我们创造了无限的可能性。</p><p>你是不是看到这里想到些什么？</p><p>我们重新造一个XXNavigationItemContainerView容器，通过<code>initWithCustomView:</code>方法加载到导航栏上，那么在XXNavigationItemContainerView视图上，我们就能做很多定制化操作了。</p><p>可能看到这里你你会觉得非常抽象，我们先看XXNavigationItemContainerView.h提供的接口以及调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">XXNavigationItemContainerView.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSUInteger, XXNavigationItemContainerLocation) &#123;</span><br><span class="line">    ZMCNavigationItemContainerLocationLeft = 0, //对应leftBarButtonItem</span><br><span class="line">    ZMCNavigationItemContainerLocationRight,    //对应rightBarButtonItem</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface XXNavigationItemContainerView : UIView</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) XXNavigationItemContainerLocation location;</span><br><span class="line">/**</span><br><span class="line"> 容器视图所包含view，view必须指定frame.size.width</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong) NSArray &lt;UIView *&gt;*items;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 初始化导航栏Custom容器视图</span><br><span class="line"></span><br><span class="line"> @param loc 容器视图所在位置</span><br><span class="line"> @return ins</span><br><span class="line"> */</span><br><span class="line">- (instancetype)initWithContainerLocation:(XXNavigationItemContainerLocation)loc;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line"></span><br><span class="line">ViewController.m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_naviBarItemsLeftContainer = [[ZMCNavigationItemContainerView alloc] initWithContainerLocation:ZMCNavigationItemContainerLocationLeft];    </span><br><span class="line">_naviBarItemsLeftContainer.items = @[self.backItem];</span><br><span class="line">self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:_naviBarItemsLeftContainer];</span><br></pre></td></tr></table></figure><p>通过这样的方式，我们只需要向Container添加元素，Container会根据添加顺序自动渲染出视图，并通过<code>initWithCustomView:</code>接口设置到导航栏的内容视图上。</p><p>通过<code>setItems:</code>方法实现容器对元素的渲染这里就不再赘述，之前有讲过_UIButtonBarStackView在5.5英寸机型有20px其余机型为16px的边距，这里来讲讲如何解决这个问题。</p><p>根据UI视觉上的具体参数，我们可以在将元素渲染进容器时调整它的整体偏移，类似这个效果:</p><p><img src="/2018/07/15/UINavigationBar定制的正确姿势/navibar_cus_img_1.png" alt=""></p><p>我们可以使用宏或者函数的方式，获取不同机型上的偏移，并且修正它，这是很容易做到的。但是这么做以后，你会发现超出父视图部分的点击事件，无法响应了。解决这个问题就涉及了事件响应链（hit-test）相关的知识了，请自行学习，这里只讲实现和解决方案，po上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    CGRect expectFrame;</span><br><span class="line">    switch (self.location) &#123;</span><br><span class="line">        case XXNavigationItemContainerLocationLeft:</span><br><span class="line">            expectFrame = CGRectMake(-NaviBar_Item_Offset, 0, self.bounds.size.width, self.bounds.size.height);</span><br><span class="line">            break;</span><br><span class="line">        case XXNavigationItemContainerLocationRight:</span><br><span class="line">            expectFrame = CGRectMake(NaviBar_Item_Offset, 0, self.bounds.size.width, self.bounds.size.height);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return CGRectContainsPoint(expectFrame, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我使用<code>NaviBar_Item_Offset</code>来定义所需修正的偏移量，在触摸事件发生响应链寻找最佳匹配视图时，修正视图位置信息并将其与触摸位置进行匹配，返回结果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统导航栏（UINavigationBar）的定制一直以来都是一个比较棘手的问题，特别在iOS11以后导航栏视图结构发生了改变，导致之前很多解决方案都不再适用。由于导航栏图层独立于控制器视图，所以你可以隐藏掉导航栏使用自己绘制的导航栏仅使用导航控制器的视图栈，但本文不推荐这
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
