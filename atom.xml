<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Paradise of Web</title>
  
  <subtitle>不会弹吉他的贝斯手，不是好程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-05T13:24:00.152Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tian Xueweii</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS Core Animation - Advanced Techniques-学习笔记（三）</title>
    <link href="http://yoursite.com/2018/11/05/iOS%20Core%20Animation-%20Advanced%20Techniques-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/05/iOS Core Animation- Advanced Techniques-学习笔记（三）/</id>
    <published>2018-11-05T12:41:37.000Z</published>
    <updated>2018-11-05T13:24:00.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><ul><li>UIView的<code>transform</code>属性，用于视图在二维空间做旋转，缩放和平移</li><li>仿射变换的定义，是指无论变换矩阵用什么值，图层中平行的两条线在变换之后仍然保持平行</li><li>Core Graphics提供的实例化仿射变换的方法<ul><li>CGAffineTransformMakeRotation(CGFloat angle) // 旋转</li><li>CGAffineTransformMakeScale(CGFloat sx, CGFloat sy) // 缩放</li><li>CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) // 平移</li></ul></li><li>CALayer也有一个<code>transform</code>属性，但它的类型是CATransform3D，而不是CGAffineTransform</li><li>Core Graphics提供了在之前变换的基础上继续变换的方法<ul><li>CGAffineTransformRotate(CGAffineTransform t, CGFloat angle)</li><li>CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)</li><li>CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)</li></ul></li><li>以及一个单位矩阵常量CGAffineTransformIdentity</li><li>我们可以利用这些函数，在必要的时候组合一个更加复杂的变化，这样的实现方式，是优雅的</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//create a new transform</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>; </span><br><span class="line">    <span class="comment">//scale by 50%</span></span><br><span class="line">    transform = <span class="built_in">CGAffineTransformScale</span>(transform, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//rotate by 30 degrees</span></span><br><span class="line">    transform = <span class="built_in">CGAffineTransformRotate</span>(transform, M_PI / <span class="number">180.0</span> * <span class="number">30.0</span>);</span><br><span class="line">    <span class="comment">//translate by 200 points</span></span><br><span class="line">    transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//apply transform to layer</span></span><br><span class="line">    <span class="keyword">self</span>.layerView.layer.affineTransform = transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h3><ul><li>和CGAffineTransform类似，CATransform3D也是一个矩阵，但是和2x3的矩阵不同，CATransform3D是一个可以在3维空间内做变换的4x4的矩阵，我们要关注zPosition</li><li><p>3D变换的方法</p><ul><li>CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)</li><li>CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) </li><li><p>CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz) </p><blockquote><p>与仿射变化的旋转不同，CATransform3DMakeRotation是绕某一个（x,y,z）轴进行旋转</p></blockquote></li></ul></li></ul><h4 id="透视效果"><a href="#透视效果" class="headerlink" title="透视效果"></a>透视效果</h4><ul><li>三维空间中，当物体原理我们时，会看起来比较小，远处的物体和近处的物体存在不同的缩放比例</li><li>为了实现透视效果，我们需要修改<code>m34</code>值，<code>m34</code>的默认值是0，我们可以通过设置<code>m34</code>为（-1.0 / d）来实现透视效果，d代表了想象中视角相机和屏幕之间的距离，以像素为单位，通常500~1000就可以了。代码如下：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//create a new transform</span></span><br><span class="line">    <span class="built_in">CATransform3D</span> transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">    <span class="comment">//apply perspective</span></span><br><span class="line">    transform.m34 = - <span class="number">1.0</span> / <span class="number">500.0</span>;</span><br><span class="line">    <span class="comment">//rotate by 45 degrees along the Y axis</span></span><br><span class="line">    transform = <span class="built_in">CATransform3DRotate</span>(transform, M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//apply to layer</span></span><br><span class="line">    <span class="keyword">self</span>.layerView.layer.transform = transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="灭点"><a href="#灭点" class="headerlink" title="灭点"></a>灭点</h4><ul><li>当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。这个点叫灭点</li><li>Core Animation定义的这个点位于变换前<code>anchorPoint</code>的位置</li><li>当一个图层有多个3D变换的子图层，我们要想让整个视图绘制的更有3D效果，应该首先把它们都放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的position），这样所有的3D图层都共享一个灭点</li></ul><h4 id="sublayerTransform属性"><a href="#sublayerTransform属性" class="headerlink" title="sublayerTransform属性"></a>sublayerTransform属性</h4><ul><li>如果图层有多个子图层都要做3D变换，那就要分别对<code>m34</code>进行设置，CALayer有一个属性叫做<code>sublayerTransform</code>，这个变换会作用于所有子图层</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//apply perspective transform to container</span></span><br><span class="line">    <span class="comment">//容器视图变换，perspective将会影响layerView1和layerView2</span></span><br><span class="line">    <span class="built_in">CATransform3D</span> perspective = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">    perspective.m34 = - <span class="number">1.0</span> / <span class="number">500.0</span>;</span><br><span class="line">    <span class="keyword">self</span>.containerView.layer.sublayerTransform = perspective;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//rotate layerView1 by 45 degrees along the Y axis</span></span><br><span class="line">    <span class="built_in">CATransform3D</span> transform1 = <span class="built_in">CATransform3DMakeRotation</span>(M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">self</span>.layerView1.layer.transform = transform1;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//rotate layerView2 by 45 degrees along the Y axis</span></span><br><span class="line">    <span class="built_in">CATransform3D</span> transform2 = <span class="built_in">CATransform3DMakeRotation</span>(-M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">self</span>.layerView2.layer.transform = transform2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图层的背面"><a href="#图层的背面" class="headerlink" title="图层的背面"></a>图层的背面</h4><ul><li>图层是双面绘制的，反面是一个镜像图片，这并不是一个很好的特性，会给用户造成困扰，同时也可能造成系统资源的浪费，试想我们不想看到背面，那为什么还要浪费GPU绘制它们？</li><li><code>doubleSided</code>属性，用来控制图层背面是否绘制，默认为YES</li></ul><h2 id="专用图层"><a href="#专用图层" class="headerlink" title="专用图层"></a>专用图层</h2><p>CALayer类具有一些非常有用的绘图和动画功能。但Core Animation不仅作用于图片和颜色，CALayer拓展了其他一些专用于某种功能的子类，以增强Core Animation的绘图能力。这里学习总结了几个常用的专用图层，其他的仅作了解</p><h3 id="CAShapeLayer-形状图层"><a href="#CAShapeLayer-形状图层" class="headerlink" title="CAShapeLayer - 形状图层"></a>CAShapeLayer - 形状图层</h3><ul><li>阴影可以使用CGPath来构建轮廓，图层也可以用这种方式构建</li><li>CAShapeLayer是一个通过矢量绘图的图层子类</li><li>比较推荐的方式是使用UIBezierPath类来帮助创建图层，这样我们不用考虑人工释放CGPath资源</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用CAShapeLayer新建图层绘制一个火柴人</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">  <span class="comment">//create path</span></span><br><span class="line">  <span class="built_in">UIBezierPath</span> *path = [[<span class="built_in">UIBezierPath</span> alloc] init];</span><br><span class="line">  [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">175</span>, <span class="number">100</span>)];</span><br><span class="line">  ￼</span><br><span class="line">  [path addArcWithCenter:<span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">100</span>) radius:<span class="number">25</span> startAngle:<span class="number">0</span> endAngle:<span class="number">2</span>*M_PI clockwise:<span class="literal">YES</span>];</span><br><span class="line">  [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">125</span>)];</span><br><span class="line">  [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">175</span>)];</span><br><span class="line">  [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">125</span>, <span class="number">225</span>)];</span><br><span class="line">  [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">175</span>)];</span><br><span class="line">  [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">175</span>, <span class="number">225</span>)];</span><br><span class="line">  [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">150</span>)];</span><br><span class="line">  [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">150</span>)];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//create shape layer</span></span><br><span class="line">  <span class="built_in">CAShapeLayer</span> *shapeLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">  shapeLayer.strokeColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">  shapeLayer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line">  shapeLayer.lineWidth = <span class="number">5</span>;</span><br><span class="line">  shapeLayer.lineJoin = kCALineJoinRound;</span><br><span class="line">  shapeLayer.lineCap = kCALineCapRound;</span><br><span class="line">  shapeLayer.path = path.CGPath;</span><br><span class="line">  <span class="comment">//add it to our view</span></span><br><span class="line">  [<span class="keyword">self</span>.containerView.layer addSublayer:shapeLayer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CAShapeLayer还有一个比较常用的用法，是绘制矩形的指定圆角，UIBezierPath有一个自动绘制圆角矩形的构造方法</li><li>目前常用的做法是在UIView的分类添加以下方法，创建图层蒙版</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addRoundedCorners:(<span class="built_in">UIRectCorner</span>)corners radius:(<span class="built_in">CGFloat</span>)radii&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span>* rounded = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span>.bounds byRoundingCorners:corners cornerRadii:<span class="built_in">CGSizeMake</span>(radii, radii)];</span><br><span class="line">    <span class="built_in">CAShapeLayer</span>* shape = [[<span class="built_in">CAShapeLayer</span> alloc] init];</span><br><span class="line">    [shape setPath:rounded.CGPath];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.layer.mask = shape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这么做有两个问题，一是当我们同时需要创建指定圆角和阴影时，不可避免要添加一个新的Container图层；二是动态修改<code>frame.size</code>时，蒙版路径并不会更新（准确说<code>pathRect</code>就是初始<code>bounds</code>值）</p></blockquote><blockquote><p>在书中提出【我们可以把CAShapeLayer作为视图的宿主图层，而不是添加一个子视图】。经过实验，一个可行的方案是，我们重写UIView的<code>+layerClass</code>方法，返回指定图层类<code>CAShapeLayer.class</code>，并在图层布局的时候指定path，注意，如果要指定CAShapeLayer背景图层着色，要使用<code>fillColor</code>属性而不能直接写<code>backgroundColor</code></p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CAShapeLayer</span>.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)layoutSublayersOfLayer:(<span class="built_in">CALayer</span> *)layer&#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSublayersOfLayer:layer];</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span>.bounds byRoundingCorners:_corners cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">10</span>, <span class="number">10</span>)];</span><br><span class="line">    _shapeLayer.path = path.CGPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//custom layer</span></span><br><span class="line">        _shapeLayer = (<span class="built_in">CAShapeLayer</span> *)<span class="keyword">self</span>.layer;</span><br><span class="line">        _corners = <span class="built_in">UIRectCornerTopRight</span> | <span class="built_in">UIRectCornerBottomRight</span> | <span class="built_in">UIRectCornerBottomLeft</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAGradientLayer-渐变图层"><a href="#CAGradientLayer-渐变图层" class="headerlink" title="CAGradientLayer - 渐变图层"></a>CAGradientLayer - 渐变图层</h3><ul><li>CAGradientLayer是用来生成两种或更多颜色平滑渐变的。通常我们绘制渐变图，会用Core Graphics的<code>CGContextDrawLinearGradient()</code>方法生成一张图片，但相较于这种方式，CAGradientLayer使用了硬件加速使整个流程更加效率，并且代码上更加简洁优雅</li><li>创建一个简单的渐变图层，此处注意接收渐变色彩数组的类型是CGColorRef，为了保证编译正常需要bridge转换</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">  [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">  <span class="comment">//create gradient layer and add it to our container view</span></span><br><span class="line">  <span class="built_in">CAGradientLayer</span> *gradientLayer = [<span class="built_in">CAGradientLayer</span> layer];</span><br><span class="line">  gradientLayer.frame = <span class="keyword">self</span>.containerView.bounds;</span><br><span class="line">  [<span class="keyword">self</span>.containerView.layer addSublayer:gradientLayer];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//set gradient colors</span></span><br><span class="line">  gradientLayer.colors = @[(__bridge <span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor].CGColor, (__bridge <span class="keyword">id</span>)[<span class="built_in">UIColor</span> blueColor].CGColor];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//set gradient start and end points</span></span><br><span class="line">  gradientLayer.startPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  gradientLayer.endPoint = <span class="built_in">CGPointMake</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAReplicatorLayer-重复图层"><a href="#CAReplicatorLayer-重复图层" class="headerlink" title="CAReplicatorLayer - 重复图层"></a>CAReplicatorLayer - 重复图层</h3><ul><li><code>CAReplicatorLayer</code>的目的是为了高效生成许多相似的图层</li><li><code>CAReplicatorLayer</code>的几个常用属性<ul><li><code>instanceCount</code>创建多少个指定图层的拷贝</li><li><code>instanceDelay</code>两次拷贝间的延迟</li><li><code>instanceTransform</code>基于上次拷贝的仿射变换</li></ul></li><li><p>一般和<code>CAAnimationGroup</code>、<code>CAShapeLayer</code>组合使用</p><blockquote><p>书中并没有举很多实用性的例子，但其实这个图层使用还是挺广泛的，例如雷达，波纹，加载球球，咻一咻效果等。总的来说，这个图层的使用需要一些想象力</p></blockquote></li></ul><h3 id="CAEmitterLayer-粒子图层"><a href="#CAEmitterLayer-粒子图层" class="headerlink" title="CAEmitterLayer - 粒子图层"></a>CAEmitterLayer - 粒子图层</h3><ul><li><code>CAEmitterLayer</code>是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。实际应用比较广泛，比如微信的红包雨，直播间的小❤❤<blockquote><p>这是一个很实用的图层，之后我会专门写一篇博客来讲讲他的使用</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变换&quot;&gt;&lt;a href=&quot;#变换&quot; class=&quot;headerlink&quot; title=&quot;变换&quot;&gt;&lt;/a&gt;变换&lt;/h2&gt;&lt;h3 id=&quot;仿射变换&quot;&gt;&lt;a href=&quot;#仿射变换&quot; class=&quot;headerlink&quot; title=&quot;仿射变换&quot;&gt;&lt;/a&gt;仿射变换&lt;/h
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Core Animation" scheme="http://yoursite.com/tags/Core-Animation/"/>
    
  </entry>
  
  <entry>
    <title>iOS Core Animation - Advanced Techniques-学习笔记（二）</title>
    <link href="http://yoursite.com/2018/11/03/iOS%20Core%20Animation-%20Advanced%20Techniques-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/03/iOS Core Animation- Advanced Techniques-学习笔记（二）/</id>
    <published>2018-11-03T08:10:53.000Z</published>
    <updated>2018-11-05T12:55:36.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图层几何学"><a href="#图层几何学" class="headerlink" title="图层几何学"></a>图层几何学</h2><h3 id="视图和图层布局差异"><a href="#视图和图层布局差异" class="headerlink" title="视图和图层布局差异"></a>视图和图层布局差异</h3><ul><li>视图上的<code>center</code>，在图层上对应叫<code>position</code></li><li><code>center</code>和<code>position</code>都代表了当前图层相对于父图层<code>anchorPoint</code>的位置</li><li>视图改变<code>frame</code>的实质是改变图层的<code>frame</code></li><li><code>frame</code>是根据<code>bounds</code>，<code>position</code>和<code>transform</code>计算而来，所以当其中任何一个值发生改变，他都会变化。相反，改变<code>frame</code>的值同样会影响到他们当中的值</li><li><code>frame</code>的宽高可能和<code>bounds</code>不一致，比如视图旋转后</li></ul><h3 id="anchorPoint属性-锚点"><a href="#anchorPoint属性-锚点" class="headerlink" title="anchorPoint属性 - 锚点"></a>anchorPoint属性 - 锚点</h3><ul><li>锚点可以理解为视图的把柄，缩放移动旋转等操作，会相对于锚点进行</li><li><code>anchorPoint</code>通过单位坐标描述，默认值是{0.5, 0.5}（图层中心）</li><li><code>anchorPoint</code>发生了改变但是<code>position</code>没有改变，所以图层会重新布局，<code>frame</code>会发生改变</li><li><code>anchorPoint</code>改变后，建议重新设置<code>frame</code>或<code>position</code></li></ul><h3 id="坐标系操作"><a href="#坐标系操作" class="headerlink" title="坐标系操作"></a>坐标系操作</h3><ul><li>CALayer提供了点或矩形在不同图层坐标系间转化的方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGPoint</span>)convertPoint:(<span class="built_in">CGPoint</span>)point fromLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line">- (<span class="built_in">CGPoint</span>)convertPoint:(<span class="built_in">CGPoint</span>)point toLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line">- (<span class="built_in">CGRect</span>)convertRect:(<span class="built_in">CGRect</span>)rect fromLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line">- (<span class="built_in">CGRect</span>)convertRect:(<span class="built_in">CGRect</span>)rect toLayer:(<span class="built_in">CALayer</span> *)layer;</span><br></pre></td></tr></table></figure><ul><li>可以通过设置<code>geometryFlipped</code>翻转整个坐标系，他是BOOL型的</li></ul><h3 id="图层的三维坐标"><a href="#图层的三维坐标" class="headerlink" title="图层的三维坐标"></a>图层的三维坐标</h3><ul><li>图层有<code>zPosition</code>和<code>anchorPointZ</code>来描述在Z轴上的位置</li><li>图层是一个完全扁平的对象，并没有更多属性来描述他在Z轴上的高度了</li><li>图层的<code>zPosition</code>除了使用CATransform3D来渲染3D动画，还可以用来调整图层的显示顺序，通常图层的显示顺序，是使用“画家的算法”不断覆盖上去的，但通过改变<code>zPosition</code>可以将图层顺序前置</li></ul><h3 id="图层HitTest"><a href="#图层HitTest" class="headerlink" title="图层HitTest"></a>图层HitTest</h3><ul><li>CALayer并不关心任何响应事件但是它有一系列的方法帮你处理事件：<code>-containsPoint:</code>和<code>-hitTest:</code></li><li><code>-containsPoint:</code>接受一个在本图层坐标系下的CGPoint，如果这个点在图层<code>frame</code>范围内就返回YES</li><li><code>-hitTest:</code>方法同样接受一个CGPoint类型参数，但返回的不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层</li><li><code>-hitTest:</code>的测算的顺序依赖于图层树的顺序，和<code>zPosition</code>改变后显示顺序无关。所以使用<code>zPosition</code>改变图层显示顺序后，事件将会无法响应</li></ul><h2 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h2><h3 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h3><ul><li><code>conrnerRadius</code>属性控制着图层角的曲率</li><li><p>书中原话是这个曲率值只影响背景颜色而不影响背景图片或是子图层</p><blockquote><p>我认为可能并不是针对背景颜色，可能是对父图层的裁剪</p></blockquote></li><li><p><code>masksToBounds</code>设置成YES的话，子图层超出父图层的区域会被裁剪，验证我上一条的猜测</p></li></ul><h3 id="图层边框"><a href="#图层边框" class="headerlink" title="图层边框"></a>图层边框</h3><ul><li><code>borderWidth</code>描述了图层边框宽度，这个边框的绘制是沿裁剪后的图层边缘，并且绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前</li><li><code>borderColor</code>描述了边框颜色信息</li></ul><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><ul><li>若需要增加阴影表现，只需要更改<code>shadowOpacity</code>属性，他是一个0.0（不可见）和1.0（完全不透明）之间的浮点数</li><li>若要改动阴影的表现，你可以使用CALayer的另外三个属性：<code>shadowColor</code>，<code>shadowOffset</code>和<code>shadowRadius</code></li><li><code>shadowRadius</code>控制了阴影的模糊度，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果的设计，更倾向于自然阴影，即值为0</li><li>阴影路径是根据寄宿图轮廓来确定的</li><li>阴影绘制在图层外部，所以<code>masksToBounds</code>设置成YES的话，阴影会被裁剪</li><li>如果想沿着内容裁切，又想保留阴影，需要用到两个图层：一个只画阴影的空的外图层，和一个用masksToBounds裁剪内容的内图层</li><li>如果在图层渲染前知道阴影形状会是什么样子的，可以指定一个<code>shadowPath</code>来提高性能</li></ul><h3 id="图层蒙版"><a href="#图层蒙版" class="headerlink" title="图层蒙版"></a>图层蒙版</h3><ul><li>通常创建一个无矩形视图最方便的方法，可以给它指定一个透明蒙板来实现，使用<code>mask</code>属性，这个属性所指向的类型就是CALayer</li><li><code>mask</code>图层的<code>color</code>属性是无关紧要的，真正重要的是图层的轮廓。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的则会被抛弃</li></ul><h3 id="拉伸过滤"><a href="#拉伸过滤" class="headerlink" title="拉伸过滤"></a>拉伸过滤</h3><ul><li><p>当图片需要显示不同的大小的时候，有一种叫做拉伸过滤的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上 </p><blockquote><p>我的理解例如需要将一张20x20图显示在40x40的图层上，为了避免图片的像素化，通过过滤算法生成新的像素图</p></blockquote></li><li><p><code>minificationFilter</code>和<code>magnificationFilter</code>属性描述了在图片需要缩小或拉伸时所用的过滤器算法</p></li><li><p>CALayer对图片的拉伸提供了三种算法</p><ul><li>kCAFilterLinear - 默认过滤器</li><li>kCAFilterNearest - 效率非常快，但会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重</li><li>kCAFilterTrilinear - 提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题</li></ul></li><li><p>如果是对于比较小的图或者是差异特别明显，极少斜线的大图，那么kCAFilterNearest既保证效率，同时又会保留最好的呈现效果</p><blockquote><p>kCAFilterLinear和kCAFilterTrilinear的差异并不明显，如果是简单图，kCAFilterNearest将会是最优选择</p></blockquote></li></ul><h3 id="组透明"><a href="#组透明" class="headerlink" title="组透明"></a>组透明</h3><ul><li>UIView的<code>alpha</code>属性和CALayer的<code>opacity</code>属性，这两个属性都是影响子层级的透明度的</li><li>理想状况下，当设置了一个图层的透明度，希望它包含的整个图层树像一个整体一样的透明效果，但实际情况，有可能因为透明度的混合叠加造成的</li><li>为了避免透明度混合造成的视觉上的混乱，可以使用<code>shouldRasterize</code>属性，来实现组透明的效果。如果设置了这个属性，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片</li><li><p>如果使用了shouldRasterize属性，就要确保你设置了<code>rasterizationScale</code>属性去匹配屏幕，以防止出现Retina屏幕像素化的问题</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btn.layer.shouldRasterize = <span class="literal">YES</span>;</span><br><span class="line">btn.layer.rasterizationScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图层几何学&quot;&gt;&lt;a href=&quot;#图层几何学&quot; class=&quot;headerlink&quot; title=&quot;图层几何学&quot;&gt;&lt;/a&gt;图层几何学&lt;/h2&gt;&lt;h3 id=&quot;视图和图层布局差异&quot;&gt;&lt;a href=&quot;#视图和图层布局差异&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Core Animation" scheme="http://yoursite.com/tags/Core-Animation/"/>
    
  </entry>
  
  <entry>
    <title>iOS Core Animation - Advanced Techniques-学习笔记（一）</title>
    <link href="http://yoursite.com/2018/11/01/iOS%20Core%20Animation-%20Advanced%20Techniques-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/01/iOS Core Animation- Advanced Techniques-学习笔记（一）/</id>
    <published>2018-11-01T11:35:10.000Z</published>
    <updated>2018-11-05T12:54:53.867Z</updated>
    
    <content type="html"><![CDATA[<p>本文是针对《iOS Core Animation: Advanced Techniques》相对重要知识点进行的总结笔记，插图和具体释义请参照原书</p><h2 id="图层树"><a href="#图层树" class="headerlink" title="图层树"></a>图层树</h2><h3 id="深刻理解图层与视图"><a href="#深刻理解图层与视图" class="headerlink" title="深刻理解图层与视图"></a>深刻理解图层与视图</h3><ul><li>视图（UIView）是在屏幕上显示的，能够拦截用户行为（如手势输入）的矩形块，视图具有层级关系并可互相嵌套。</li><li>图层（CALayer）和视图（UIView）在概念上类似，和视图最大的不同，是图层不处理用户行为。</li><li>在iOS和MacOS两个平台上，事件和用户交互有很多不同，UIKit和AppKit就是基于CoreAnimation针对两个平台的不同处理框架。</li></ul><h3 id="为什么要使用图层"><a href="#为什么要使用图层" class="headerlink" title="为什么要使用图层"></a>为什么要使用图层</h3><ul><li>UIView的接口优美而简洁，但这种简单会造成灵活性上的缺陷。</li><li>UIView没有暴露出的CALayer一些功能：<ul><li>阴影，圆角，带颜色的边框</li><li>3D变换</li><li>非矩形范围</li><li>透明遮罩</li><li>多级非线性动画</li></ul></li></ul><h3 id="如何使用图层"><a href="#如何使用图层" class="headerlink" title="如何使用图层"></a>如何使用图层</h3><ul><li>UIView视图类带有一个CALayer属性可直接使用</li><li>把QuartzCore引入到项目，然后调用CALayer初始化方法创建</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//create sublayer</span></span><br><span class="line">    <span class="built_in">CALayer</span> *sublayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    sublayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">50.0</span>f, <span class="number">50.0</span>f, <span class="number">100.0</span>f, <span class="number">100.0</span>f);</span><br><span class="line">    sublayer.backgroundColor = [<span class="built_in">UIColor</span> blueColor].CGColor;</span><br><span class="line">    <span class="comment">//add it to view</span></span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:sublayer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寄宿图"><a href="#寄宿图" class="headerlink" title="寄宿图"></a>寄宿图</h2><h3 id="contents属性"><a href="#contents属性" class="headerlink" title="contents属性"></a>contents属性</h3><ul><li>CALayer有一个属性<code>contents</code>，它是id类型的，在iOS平台上需要被赋值的类型是<code>CGImageRef</code>，一个指向CGImage结构的指针。在Mac平台上需要被赋值<code>NSImage</code>对象</li><li><code>contents</code>属性能够让图层不仅展示一个背景色，可以展示一个图片</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ViewController.m</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="keyword">super</span> viewDidLoad]; <span class="comment">//load an image</span></span><br><span class="line">  <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx.png"</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//add it directly to our view's layer</span></span><br><span class="line">  <span class="keyword">self</span>.layerView.layer.contents = (__bridge <span class="keyword">id</span>)image.CGImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="contentGravity属性"><a href="#contentGravity属性" class="headerlink" title="contentGravity属性"></a>contentGravity属性</h3><ul><li>类似于UIImageView的<code>contentMode</code>，在CALayer中对应的属性叫做<code>contentsGravity</code>，它是一个NSString类型，可选常量：<ul><li><code>kCAGravityCenter</code>        水平垂直居中</li><li><code>kCAGravityTop</code>            水平居中，顶部边缘为0</li><li><code>kCAGravityBottom</code>        水平居中，底部边缘为0</li><li><code>kCAGravityLeft</code>            垂直居中，左部边缘为0</li><li><code>kCAGravityRight</code>            垂直居中，右部边缘为0</li><li><code>kCAGravityTopLeft</code>        左上边缘为0</li><li><code>kCAGravityTopRight</code>        右上边缘为0</li><li><code>kCAGravityBottomLeft</code>    左下边缘为0</li><li><code>kCAGravityBottomRight</code>    右下边缘为0</li><li><code>kCAGravityResize</code>        根据图层大小拉伸</li><li><code>kCAGravityResizeAspect</code>            整个图片等比渲染全部展示到图层，可能会有留白</li><li><code>kCAGravityResizeAspectFill</code>    整个图片等比渲染铺满图层，图片可能被截断</li></ul></li></ul><h3 id="contentsScale属性"><a href="#contentsScale属性" class="headerlink" title="contentsScale属性"></a>contentsScale属性</h3><ul><li><code>contentsScale</code>属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</li><li>这个属性在开发中没有找到具体的应用场景，不建议直接使用</li></ul><h3 id="maskToBounds属性"><a href="#maskToBounds属性" class="headerlink" title="maskToBounds属性"></a>maskToBounds属性</h3><ul><li>将超出图层边界的内容截断</li><li>【注意】设置阴影也会被这个属性截断，因为阴影是绘制在图层外的</li></ul><h3 id="contentsRect属性"><a href="#contentsRect属性" class="headerlink" title="contentsRect属性"></a>contentsRect属性</h3><ul><li>这个属性允许我们选择寄宿图的一个子域，这个属性比<code>contentGravity</code>更灵活</li><li>和<code>bounds</code>，<code>frame</code>不同，<code>contentsRect</code>不是按点来计算的，它使用了单位坐标，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）</li><li>默认的<code>contentsRect</code>是{0, 0, 1, 1}，意味着整个图片可见</li><li>通过这个属性，我们可以实现Image Sprites（图片拼合技术），图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等。</li><li>图片拼合技术在游戏中应用较多，如一段连续的奔跑动画🏃</li></ul><h3 id="contentsCenter属性"><a href="#contentsCenter属性" class="headerlink" title="contentsCenter属性"></a>contentsCenter属性</h3><ul><li><code>contentsCenter</code>是一个CGRect结构，它定义了一个固定的边框和一个在图层上可拉伸的区域。</li><li>它的工作效果和UIImage里的<code>-resizableImageWithCapInsets:</code>方法效果非常类似</li><li>在开发中目前还没有实际运用到它，应用后更新使用场景</li></ul><h3 id="视图-drawRect-方法"><a href="#视图-drawRect-方法" class="headerlink" title="视图-drawRect:方法"></a>视图-drawRect:方法</h3><ul><li>设置寄宿图的方法，不止有给<code>contents</code>属性赋值这种方式，还能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制</li><li>寄宿图不是必须的，但是只要UIView检测到<code>-drawRect:</code>，那么系统就会为这个视图图层分配一个寄宿图，该寄宿图的尺寸等于视图大小乘以 <code>contentsScale</code>的值</li><li>如果不需要寄宿图，<code>-drawRect:</code>请不要实现，会浪费资源</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是针对《iOS Core Animation: Advanced Techniques》相对重要知识点进行的总结笔记，插图和具体释义请参照原书&lt;/p&gt;
&lt;h2 id=&quot;图层树&quot;&gt;&lt;a href=&quot;#图层树&quot; class=&quot;headerlink&quot; title=&quot;图层树&quot;&gt;
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Core Animation" scheme="http://yoursite.com/tags/Core-Animation/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript异步和事件循环机制</title>
    <link href="http://yoursite.com/2018/10/14/JavaScript%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/10/14/JavaScript异步和事件循环机制/</id>
    <published>2018-10-14T13:05:24.000Z</published>
    <updated>2018-10-14T13:08:23.570Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript（以下简称js）的语言执行环境是单线程（single thread）的，这是其用途而决定的，作为浏览器脚本语言，js的主要用途是与用户互动，以及操作DOM，在iOS开发上的理解就是操作UI（只有主线程才能对UI进行操作）。所以为了避免语言的复杂性，单线程成为了js的核心特质，将来也不会轻易改变。</p><p>但异步编程又非常重要，没有异步操作在进行耗时任务卡顿感会非常严重。所以目前JavaScript主要提供了三种异步方式：回调函数、事件监听、Promise对象。</p><p>这篇文章我们将使用三种方式实现同一个登录网络请求的Mock方法，来模拟js的异步执行。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>在iOS开发中，我们的一般做法就是在参数中指定回调函数，直观并且容易理解。在js中做法可能更加自由，例如微信小程序OpenApi，直接指定参数为一个对象，对象分别指定相关参数和回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  url: <span class="string">'test.php'</span>, <span class="comment">//仅为示例，并非真实的接口地址</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    x: <span class="string">''</span>,</span><br><span class="line">    y: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  header: &#123;</span><br><span class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json'</span> <span class="comment">// 默认值</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们使用回调函数的方式实现异步回调，代码片段如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request_callback</span>(<span class="params">url, param, success, fail</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求:'</span> + url + <span class="string">'中...'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            success(response, param);   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fail(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">request_callback(url, params, </span><br><span class="line">    (response, params) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'用户名：'</span> + params.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'密码：'</span> + params.sec);</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>该实现借鉴jQuery的trigger写法，类似于iOS开发中的消息通知（一对多）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listener;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request_trigger</span>(<span class="params">url, params</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求:'</span> + url + <span class="string">'中...'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            listener.trigger(<span class="string">'success'</span>, response);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            listener.trigger(<span class="string">'fail'</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listener.on(<span class="string">'success'</span>, (response, params) =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(response);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'用户名：'</span> + params.name);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'密码：'</span> + params.sec);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">listener.on(<span class="string">'fail'</span>, (error) =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>比较官方的解释：Promise对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。</p><p>个人理解，Promise就是对一个异步流程的封装，ES6为这种流程的封装提供了一种标准的方法，并取了一个好听的名字。Promise译为承诺，承诺那么就要有反馈，Promise就是规范了这种反馈的方式，由程序员决定反馈的时机。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request_promise</span>(<span class="params">url, params</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求:'</span> + url + <span class="string">'中...'</span>);</span><br><span class="line">    <span class="comment">//Promise 新建后就会立即执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                resolve(response);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">request_promise(url, params)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'用户名：'</span> + params.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'密码：'</span> + params.sec);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>阮一峰大神在ES6入门中，举了一个使用Promise封装图片加载的例子，通过这个例子我们可以更深刻理解Promise对异步&lt;流程&gt;的封装，这种方式非常美妙：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">        image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(image);</span><br><span class="line">        &#125;;</span><br><span class="line">        image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + url));</span><br><span class="line">        &#125;;</span><br><span class="line">        image.src = url;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise实现异步流程控制"><a href="#Promise实现异步流程控制" class="headerlink" title="Promise实现异步流程控制"></a>Promise实现异步流程控制</h2><p>解决异步回调，可是后台接口并不如我们前端程序员想的那么好用。如果我们要在请求登录之前，需要先请求init接口获取初始化数据，那代码会变成什么样？看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 请求init获取初始化数据</span></span><br><span class="line"><span class="comment"> * 2. 请求登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">request_callback(initUrl, params, </span><br><span class="line">    (response, params) =&gt; &#123;</span><br><span class="line">        <span class="comment">//嵌套</span></span><br><span class="line">        request_callback(url, params,</span><br><span class="line">            (response, params) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(response);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'用户名：'</span> + params.name);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'密码：'</span> + params.sec);</span><br><span class="line">            &#125;,</span><br><span class="line">            (error) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(error);</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样的嵌套方式，简直就是灾难，使用Promise的链式语法，可以将上述代码重构成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestInitUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'请求'</span> + url + <span class="string">'前需先请求'</span> + initUrl);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'请求:'</span> + initUrl + <span class="string">'中...'</span>);</span><br><span class="line">        setTimeout(resolve, <span class="number">4000</span>, url);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开始请求...'</span>);</span><br><span class="line">        setTimeout(resolve, <span class="number">4000</span>, url);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">request(url, params)</span><br><span class="line">    .then(requestInitUrl)</span><br><span class="line">    .then(request_promise)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'用户名：'</span> + params.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'密码：'</span> + params.sec);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="Generator实现异步流程控制"><a href="#Generator实现异步流程控制" class="headerlink" title="Generator实现异步流程控制"></a>Generator实现异步流程控制</h2><p>通过上个Section代码的实现，看样子是解决了问题，但是我们却需要实现一个requestInitUrl函数来封装第一次init请求，并且第二次请求的参数和调用并不在一起，总感觉不是很优雅。值得开心的是，ES6中提供了新的解决方案Generator，上述代码可以重构成这样，无需再重新封装一个初始化请求的Promise对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fullRequest_generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> request_promise(initUrl)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'初始化'</span> + response);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">yield</span> request_promise(url, params)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'登录'</span> + response);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'finish'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="keyword">var</span> fr_g = fullRequest_generator();</span><br><span class="line"><span class="comment">//错误的调用方式</span></span><br><span class="line"><span class="comment">// fr_g.next();</span></span><br><span class="line"><span class="comment">// fr_g.next();</span></span><br><span class="line"><span class="comment">// fr_g.next();</span></span><br></pre></td></tr></table></figure><p>执行后我们会发现，程序执行的结果并不是我们想要的异步控制，所有的请求其实是【同步】执行的。</p><p>所以，一个单纯的Generator并不能完成异步控制。Generator异步需要两个条件，一是每个yield表达式返回一个Promise对象，二是需要一个执行器。通过引入’co’模块，解决了异步执行的问题，将以上代码改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</span><br><span class="line">co(fr_g)</span><br></pre></td></tr></table></figure><p>ps: co模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator函数的自动执行。</p><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h2><p>作为一个傲娇的程序员，引入别人的模块万一出问题还要去读源码，不是自己写的代码总有点不放心。所以在ES7中，提供了Generator函数的语法糖Async/Await解决了Generator异步执行的问题。Async函数的实现，就是将Generator函数和自动执行器，包装在一个函数里。我们将上述代码重构成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fullRequest_async</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开始任务'</span>);</span><br><span class="line">    <span class="keyword">await</span> request_promise(initUrl)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'初始化'</span> + response);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> request_promise(url, params)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'登录'</span> + response);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'结束任务'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">fullRequest_async();</span><br></pre></td></tr></table></figure><p>看到以上代码的实现，是不是感觉非常优雅美丽并且酷炫，我们不用单独声明流程函数，也不用引入执行器，就完成了异步任务的流程控制，并且提升了代码的可读性。(๑•̀ㅂ•́)و✧</p><p>如果要将任务结果抛出，则上述代码还可以重构为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fullRequest_async</span>(<span class="params">comp, fail</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开始任务'</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> request_promise(initUrl)</span><br><span class="line">        .then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'初始化'</span> + response);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">await</span> request_promise(url, params)</span><br><span class="line">        .then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'登录'</span> + response);</span><br><span class="line">        &#125;)</span><br><span class="line">        comp();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        fail(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fullRequest_async(</span><br><span class="line">()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'结束任务'</span>);</span><br><span class="line">&#125;,</span><br><span class="line">(err)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'终止任务'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h2><p>讲了代码的实现方式，让我们简单探究下js底层对异步任务的处理机制</p><p><img src="/2018/10/14/JavaScript异步和事件循环机制/bg2014100802.png" alt=""></p><p>由于js的单线程机制，所以我们可以暂时不管线程这个概念，将所有即将执行的任务分为同步任务（synchronous），和异步任务（asynchronous）。同步任务指的是，在内存栈上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，当某个事件完成触发而进入”任务队列”（task queue）的任务。而读取任务队列中任务的操作，永远是在栈中任务执行完成后的。</p><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p><p>一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">'GET'</span>, url);    </span><br><span class="line">req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;    </span><br><span class="line">req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;    </span><br><span class="line">req.send();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">'GET'</span>, url);        </span><br><span class="line">req.send();</span><br><span class="line">req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;    </span><br><span class="line">req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>如果用iOS开发的角度来看，我们是不确定<code>onload</code>和<code>onerror</code>回调时机的，但是在js的事件循环中，这两种写法是等价的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从几种异步回调方式来看，不论是回调函数、事件还是Promise，免不了套娃的感觉。于我个人的开发习惯，比较喜欢使用类似微信小程序Api的回调方式，将参数和回调通过对象封装后传参的形式，这样的写法更加自由，清爽，并且容易控制（最主要的是作为一个iOSer毫无学习压力）。</p><p>事件监听的方式可以将回调的实现和调用分离开，达到解耦的目的，逻辑分离所带来的问题就是代码理解成本、维护成本的提高。</p><p>Promise封装了整个异步流程，相对于回调函数和事件，可以用更优雅的方式做更多的事情，例如多个异步任务的串行实现，但需要深刻理解Promise对象的实现机制，提高了学习成本。</p><p>ES6提供的Generator函数将异步代码使用同步代码的形式表现，但并不能直接解决异步流程控制，需要引入或实现执行器。</p><p>ES7提供的Async/Await语法糖，则进一步封装了整个流程，相比较Generator实现，无需实现执行器，task函数可直接执行，使代码书写更优雅，可读性更好。</p><p>所以，在实际开发中，如果无需负责流程控制的异步操作或者需要提供给外部使用的Api建议直接使用回调函数的方式进行封装。若需要对异步流程进行过控制，则将异步操作封装成Promise对象，用Async/Await的方式进行控制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript（以下简称js）的语言执行环境是单线程（single thread）的，这是其用途而决定的，作为浏览器脚本语言，js的主要用途是与用户互动，以及操作DOM，在iOS开发上的理解就是操作UI（只有主线程才能对UI进行操作）。所以为了避免语言的复杂性，单线程
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node环境搭建</title>
    <link href="http://yoursite.com/2018/08/13/Node%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/08/13/Node环境搭建/</id>
    <published>2018-08-13T01:50:58.000Z</published>
    <updated>2018-08-13T06:42:51.113Z</updated>
    
    <content type="html"><![CDATA[<p>由于Node.js版本更新快，版本差异性大，推荐使用3m来管理配置环境：</p><ul><li>nvm(Node.js Version Manager)：解决多版本共存、切换问题</li><li>npm(Node.js Package Manager)：解决Node.js模块安装问题，其本身是一个Node.js模块</li><li>nrm(Node.js Registry Manager)：解决npm镜像访问慢的问题，提供测速、切换registry功能</li></ul><h2 id="NVM"><a href="#NVM" class="headerlink" title="NVM"></a>NVM</h2><h3 id="nvm安装命令"><a href="#nvm安装命令" class="headerlink" title="nvm安装命令"></a>nvm安装命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash</span><br></pre></td></tr></table></figure><p>通过curl下载install.sh脚本并执行，待执行完成后，它会把nvm命令的执行路径放到~/.bashrc文件里，通过执行source命令，使环境变量生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="nvm的常用命令"><a href="#nvm的常用命令" class="headerlink" title="nvm的常用命令"></a>nvm的常用命令</h3><ul><li>安装：<code>$ nvm install 4.4.5</code></li><li>设置默认：<code>$ nvm alias default 4.4.5</code></li><li>切换版本：<code>$ nvm use 6</code></li><li>列出当前本地版本：<code>$ nvm ls</code></li><li>列出远端可安装版本：<code>$ nvm ls-remote</code></li></ul><p>可以说这5个命令在开发过程中足够用，其实nvm还有很多高级特性，比如在项目根目录创建.npmrc指定特定的Node.js版本，它就切换到对应版本，类似的很多，就不一一列举了</p><h2 id="NRM"><a href="#NRM" class="headerlink" title="NRM"></a>NRM</h2><p>仓库源管理工具，源类似于pods的repo管理。<br>cnpm源每5分钟更新一次，如果上传了新的package使用cnpm不能马上获取更新</p><h3 id="nrm安装命令"><a href="#nrm安装命令" class="headerlink" title="nrm安装命令"></a>nrm安装命令</h3><p>nrm是Node.js的模块，可直接使用npm来安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install --global nrm</span><br></pre></td></tr></table></figure><h3 id="nrm的常用命令"><a href="#nrm的常用命令" class="headerlink" title="nrm的常用命令"></a>nrm的常用命令</h3><ul><li>测速：<code>$ nrm test</code></li><li>查看源：<code>$ nrm ls</code></li><li>切换源：<code>$ nrm use cnpm</code></li></ul><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>当安装好Node.js环境后，就已经自带了npm管理工具</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于Node.js版本更新快，版本差异性大，推荐使用3m来管理配置环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nvm(Node.js Version Manager)：解决多版本共存、切换问题&lt;/li&gt;
&lt;li&gt;npm(Node.js Package Manager)：解决Node.
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>iOS架构补完计划</title>
    <link href="http://yoursite.com/2018/08/12/iOS%E6%9E%B6%E6%9E%84%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2018/08/12/iOS架构补完计划/</id>
    <published>2018-08-12T12:12:28.000Z</published>
    <updated>2018-08-13T07:18:47.616Z</updated>
    
    <content type="html"><![CDATA[<p>移动端架构上的设计，本质上都是三个角色：数据结构、数据流管理、数据展示。</p><p>不管是MVC、MVVM、MVP、VIPER或者任何新的设计模式、都跳不出这三个角色。无非是把数据管理者的工作进行拆分、唯一的界定标准就是把工作拆分的粒度大小。<br>而无论哪种思想、最终都逃不开三个问题的《《取舍》》。代码量、通用性、可读性。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC就是典型的着重通用型与可读性、这正是一个作为万物之初的架构所需要保证的事。简单、易学。</p><h3 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h3><ul><li>Model：数据结构，数据映射</li><li>View：数据展示</li><li>Controller：负责根据需求对Model及View间的数据流调配</li></ul><h3 id="Controller的瘦身"><a href="#Controller的瘦身" class="headerlink" title="Controller的瘦身"></a>Controller的瘦身</h3><p>不过和广义的MVC不同，iOS端由于UIViewController自带一个容器View。所以除了上述的正统任务之外，Controller还需要承担View的生成，布局等的任务。Controller实际上是Controller+View的一个角色，这样的设定也导致了C层过于臃肿的问题</p><ul><li><p>胖Model</p><p>  主旨是Controller从Model里拿到的数据、不需要进行更多的判断、处理等操作、就能使用。缺点是移植困难、复用困难</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Json Data:</span><br><span class="line">timestamp:1234567</span><br><span class="line"></span><br><span class="line">FatModel:</span><br><span class="line">@property (nonatomic, assign) CGFloat timestamp;</span><br><span class="line">- (NSString *)ymdDateString; // 2015-04-20 15:16</span><br><span class="line">- (NSString *)standardString; // 3分钟前、1小时前、一天前</span><br><span class="line"></span><br><span class="line">Controller:</span><br><span class="line">self.dateLabel.text = [FatModelIns ymdDateString];</span><br><span class="line">self.gapLabel.text = [FatModelIns standardString];</span><br></pre></td></tr></table></figure></li><li><p>瘦Model</p><p>  就是要把MVC的M贯彻倒底、除了业务的表达啥都不管。所以瘦Model要借助一些外来的辅助模块（索性可以叫Helper、Util）来对弱业务做抽象。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Json Data:</span><br><span class="line">&#123;</span><br><span class="line">   &quot;name&quot;:&quot;casa&quot;,</span><br><span class="line">   &quot;sex&quot;:&quot;male&quot;,</span><br><span class="line">&#125;</span><br><span class="line">SlimModel:</span><br><span class="line">   @property (nonatomic, strong) NSString *name;</span><br><span class="line">   @property (nonatomic, strong) NSString *sex;</span><br><span class="line">Util:</span><br><span class="line">   #define Male 1;</span><br><span class="line">   #define Female 0;</span><br><span class="line">   + (BOOL)sexWithString:(NSString *)sex;</span><br><span class="line">Controller:</span><br><span class="line">   if ([Helper sexWithString:SlimModel.sex] == Male) &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>总结：虽然胖瘦Model都一定程度上尝试解决Controller过于臃肿的问题，但是仅仅停留在数据处理、格式化层面，真正的业务逻辑、交互逻辑依然存放于Controller中</p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>本质上与MVVM没有区别，只是将Controller中关于Model和数据处理的代码移植到Presenter中，但是MVP并不是一个完全剥离业务逻辑的设计模式</p><h3 id="架构模型-1"><a href="#架构模型-1" class="headerlink" title="架构模型"></a>架构模型</h3><ul><li><p>View</p><p>  负责界面结构和布局管理，通过Presenter暴露的数据更新和数据获取的接口进行展示</p></li><li><p>Presenter</p><p>  负责处理数据，并提供刷新反馈接口，并管理Model。</p></li><li><p>Model</p><p>  和MVC中的一样，提供数据模型和映射</p></li></ul><p><img src="/2018/08/12/iOS架构补完计划/mvp.jpg" alt=""></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM起源于前端，这种抽离模型响应式架构在Web开发及小程序开发中已经十分普及，在大厂甚至成为一种标准存在。MVVM的出现，为移动端开发Controller/Activity的瘦身带来启发，刚才讲到的胖Model只从Controller中移植了一些简单的弱业务，而大量的交互逻辑仍存放在Controller中</p><h3 id="MVVM力求解决的开发痛点"><a href="#MVVM力求解决的开发痛点" class="headerlink" title="MVVM力求解决的开发痛点"></a>MVVM力求解决的开发痛点</h3><ul><li>过长的数据响应链，每次数据更新都要向上层传递</li><li>控制器层代码臃肿。由于UIKit框架的设计原因，UIViewController承担了过多不应承担的责任，Controller内包含了数据、界面、逻辑元素，只能通过规范约束，难以管理</li><li>架构层面结构划分不清晰，增加了移动端的学习难度</li></ul><h3 id="架构模型-2"><a href="#架构模型-2" class="headerlink" title="架构模型"></a>架构模型</h3><ul><li><p>Model</p><p>  和MVC中的瘦Model一样。只承载最基本的数据单元和数据映射。</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UserModel</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *userName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *sex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>View</p><p>  View层包含了UIKit框架下，UIView和UIViewController及其子类。在View层中只需要编写页面展示模板和数据绑定，不写任何业务逻辑。</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)awakeFromNib &#123;</span><br><span class="line">   [<span class="keyword">super</span> awakeFromNib];</span><br><span class="line">   RAC(<span class="keyword">self</span>.userNameLabel, text) = RACObserve(<span class="keyword">self</span>, viewModel.userName);</span><br><span class="line">   RAC(<span class="keyword">self</span>.userSexLabel, text) = RACObserve(<span class="keyword">self</span>, viewModel.sex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ViewModel</p><p>  ViewModel里涵盖了所有View层绑定需要的数据模型、逻辑函数、事件响应函数。当数据发生改变，View层会响应式渲染更新界面。</p></li></ul><h3 id="RAC对于MVVM的意义"><a href="#RAC对于MVVM的意义" class="headerlink" title="RAC对于MVVM的意义"></a>RAC对于MVVM的意义</h3><p>RAC(ReactiveCocoa)并不是MVVM思想的核心，不用RAC也能使用MVVM。但是使用RAC能更好的体现MVVM的精髓，即数据绑定处理、响应式渲染。就像Web开发中，使用React、Vue那样。在MVC中，M和V若无持有关系，在数据传递和渲染时会造成很多麻烦，那么如何把原本松散的两者通过中间层联系起来（数据绑定），在iOS本身并没有太靠谱的办法，在Vue中有<code></code>这种优雅的写法。</p><p>虽然KVO、Notification、block、delegate和target-action都可以用来做数据通信进而实现绑定，但都不如RAC来的《《优雅》》。</p><h2 id="关于架构设计的一些观点"><a href="#关于架构设计的一些观点" class="headerlink" title="关于架构设计的一些观点"></a>关于架构设计的一些观点</h2><ul><li><p>控制好Controller的代码量</p><p>  随着项目的进行、代码量最多只能优化、膨胀不可避免。而在没办法继续精简的前提下、想控制Controller的代码量。就要在可读性和通用性之间进行取舍。该挪走的时候就挪走吧、毕竟梳理一个单独的模块、比梳理一个几千行的Controller要方便多了。</p></li><li><p>对于MVX如何选择</p><ul><li>其实完全要看业务性质以及项目复杂度</li><li>如果你一个页面只有一个UITableView，搞出一些奇淫技巧其实意义不大，徒增烦恼。踏踏实实用MVC对大家都好。</li><li>如果业务中View存在多种样式风格，底层数据处理存在大量复用的情况，可以使用MVP</li><li>如果业务相当的复杂，耦合让人浑身难受。做好模块化或者干脆VIPER才是出路。</li><li>如果你追求如前端MVVM框架（Vue、React）一般的开发体验，可以尝试使用RAC，但不建议单独脱离RAC使用MVVM架构</li></ul></li><li><p>无论用哪种模式、都要深刻的理解每个模块不同的职责</p></li></ul><p>ps: 本文基于CocoaChina博主kirito_song的文章，并整理了近期项目实践撰写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;移动端架构上的设计，本质上都是三个角色：数据结构、数据流管理、数据展示。&lt;/p&gt;
&lt;p&gt;不管是MVC、MVVM、MVP、VIPER或者任何新的设计模式、都跳不出这三个角色。无非是把数据管理者的工作进行拆分、唯一的界定标准就是把工作拆分的粒度大小。&lt;br&gt;而无论哪种思想、最终
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>实现虾米音乐首页视差滚动特效</title>
    <link href="http://yoursite.com/2018/07/20/%E5%AE%9E%E7%8E%B0%E8%99%BE%E7%B1%B3%E9%9F%B3%E4%B9%90%E9%A6%96%E9%A1%B5%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8%E7%89%B9%E6%95%88/"/>
    <id>http://yoursite.com/2018/07/20/实现虾米音乐首页视差滚动特效/</id>
    <published>2018-07-20T11:30:28.000Z</published>
    <updated>2018-08-13T07:17:21.293Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目迭代了一个新的版本，由于我们的设计师是虾米音乐的忠实粉丝，首页借鉴了虾米8.0首页的视差动画，在预研实现过程中有一些值得记录和分享的地方</p><h2 id="虾米音乐8-0首页鉴赏"><a href="#虾米音乐8-0首页鉴赏" class="headerlink" title="虾米音乐8.0首页鉴赏"></a>虾米音乐8.0首页鉴赏</h2><p>先看看虾米首页最终的展示效果，搜索栏会随着内容视图滚动偏移渐隐，内容视图有一个视差滚动的效果，达到滚动阈值后搜索栏会隐藏。</p><p>细心的同学可能会发现，Banner与导航栏滚动的速度相同，所以实现的难点，是如何实现Banner图与导航栏的相对静止，同时在表视图滚动到既定偏移量时，Banner图被表视图遮盖的效果。</p><p><img src="/2018/07/20/实现虾米音乐首页视差滚动特效/xiamiHomePage.gif" alt=""></p><h2 id="页面结构分析"><a href="#页面结构分析" class="headerlink" title="页面结构分析"></a>页面结构分析</h2><p>从呈现结果来看，整个视图可以分为两个部分，导航视图（CusNavigationView）及内容视图（MainContentView）。</p><p>导航视图同时包含了一个自定义搜索栏（SearchBar），自定义二级导航栏（NavigationBarLevel2），这个二级导航栏的实现我会单独写一篇博客来讲。</p><p>内容视图是一个表视图（TableView），以及使用表视图的头视图来添加轮播图（BannerView）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┏ CusNavigationView</span><br><span class="line">┃┣ SearchBar</span><br><span class="line">┃┗ NavigationBarLevel2</span><br><span class="line">┗ MainContentView</span><br><span class="line">┣ BannerView</span><br><span class="line">┗ TableView</span><br></pre></td></tr></table></figure><p>此处导航视图为了更好监听MainContentView的滚动偏移对子视图进行控制，没有使用系统的NavigationBar，而采用了自定义的方式。</p><h2 id="让我们实现她！"><a href="#让我们实现她！" class="headerlink" title="让我们实现她！"></a>让我们实现她！</h2><p>在开始编写逻辑前，先根据上个Section分析的视图结构，声明相关视图属性及导航栏折叠前高度与折叠后高度</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ZMC_Fold_Height 44//折叠后高度</span></span><br><span class="line"><span class="meta">#define ZMC_Unfold_Height 94 //折叠前高度</span></span><br><span class="line"><span class="meta">#define ZMC_Fold_Height_Offset (ZMC_Unfold_Height - ZMC_Fold_Height)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Navi</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *cusNavigationView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *searchBarView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *segmentBarView;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Table</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITableView</span> *contentTableView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *bannerView;</span><br></pre></td></tr></table></figure><p>首先先实现视差滚动效果，我们通过实现ScrollView代理，监听滚动事件，通过计算折叠动画内滚动进度比的方式，控制各个视图的相关属性，达到视差效果，代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = <span class="keyword">self</span>.contentTableView.contentOffset.y + ZMC_Fold_Height_Offset;</span><br><span class="line">    <span class="built_in">CGFloat</span> ratio = offsetY / ZMC_Fold_Height_Offset;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果有banner头视图</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.contentTableView.tableHeaderView isEqual:<span class="keyword">self</span>.bannerView]) &#123;</span><br><span class="line">        <span class="comment">//表格视图需要移动banner.height + ZMC_Fold_Height_Offset</span></span><br><span class="line">        <span class="comment">//banner和navi相对静止</span></span><br><span class="line">        <span class="comment">//移动比为 ZMC_Fold_Height_Offset / banner.height + ZMC_Fold_Height_Offset</span></span><br><span class="line">        ratio = offsetY / (<span class="keyword">self</span>.bannerView.frame.size.height + ZMC_Fold_Height_Offset);</span><br><span class="line">        [_contentTableView sendSubviewToBack:<span class="keyword">self</span>.bannerView];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ratio &gt; <span class="number">0</span> &amp;&amp; ratio &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.cusNavigationView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.height.mas_equalTo(ZMC_Unfold_Height - ZMC_Fold_Height_Offset * ratio);</span><br><span class="line">        &#125;];</span><br><span class="line">        [<span class="keyword">self</span>.searchBarView setAlpha:<span class="number">1</span> - ratio];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.contentTableView.tableHeaderView isEqual:<span class="keyword">self</span>.bannerView]) &#123;</span><br><span class="line">            [_banner mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                make.top.mas_equalTo(ratio * <span class="keyword">self</span>.bannerView.frame.size.height + <span class="number">20</span>);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ratio &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.cusNavigationView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.height.mas_equalTo(ZMC_Unfold_Height);</span><br><span class="line">        &#125;];</span><br><span class="line">        [<span class="keyword">self</span>.searchBarView setAlpha:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.contentTableView.tableHeaderView isEqual:<span class="keyword">self</span>.bannerView]) &#123;</span><br><span class="line">            [_banner mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                make.top.mas_equalTo(<span class="number">20</span>);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ratio &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.cusNavigationView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.height.mas_equalTo(ZMC_Fold_Height);</span><br><span class="line">        &#125;];</span><br><span class="line">        [<span class="keyword">self</span>.searchBarView setAlpha:<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.contentTableView.tableHeaderView isEqual:<span class="keyword">self</span>.bannerView]) &#123;</span><br><span class="line">            [_banner mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                make.top.mas_equalTo(<span class="keyword">self</span>.bannerView.frame.size.height + <span class="number">20</span>);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光实现了视差滚动还不够，如果滚动到一半位置会出现半遮半掩的效果，非常影响体验，于是我们新建一个名为<code>magneticScrollView:</code>的方法，用于控制在结束滚动时进行视图检查，如果进度比在0~1之间，则根据既定阈值调整视图位置，达到弹性效果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)magneticScrollView:(<span class="built_in">UIScrollView</span> *)sc&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = <span class="keyword">self</span>.contentTableView.contentOffset.y + ZMC_Fold_Height_Offset;</span><br><span class="line">    <span class="built_in">CGFloat</span> ratio = offsetY / ZMC_Fold_Height_Offset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果有banner头视图</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.contentTableView.tableHeaderView isEqual:<span class="keyword">self</span>.bannerView]) &#123;</span><br><span class="line">        <span class="comment">//表格视图需要移动banner.height + ZMC_Fold_Height_Offset</span></span><br><span class="line">        <span class="comment">//banner和navi相对静止</span></span><br><span class="line">        <span class="comment">//移动比为 ZMC_Fold_Height_Offset / banner.height + ZMC_Fold_Height_Offset</span></span><br><span class="line">        ratio = offsetY / (<span class="keyword">self</span>.bannerView.frame.size.height + ZMC_Fold_Height_Offset);</span><br><span class="line">        [_contentTableView sendSubviewToBack:<span class="keyword">self</span>.bannerView];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ratio &gt; <span class="number">1</span> || ratio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ratio &lt;= <span class="number">0.5</span>) &#123;</span><br><span class="line">        [sc setContentOffset:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, -ZMC_Fold_Height_Offset) animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ratio &gt; <span class="number">0.5</span> &amp;&amp; ratio &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        [sc setContentOffset:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, [<span class="keyword">self</span>.contentTableView.tableHeaderView isEqual:<span class="keyword">self</span>.bannerView] ? <span class="keyword">self</span>.bannerView.frame.size.height : <span class="number">0</span>) animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法如果在滚动视图存在减速的情况下，则在减速完成后调用，若不存在减速，则直接调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate&#123;</span><br><span class="line">    <span class="keyword">if</span> (!decelerate) &#123;</span><br><span class="line">        [<span class="keyword">self</span> magneticScrollView:scrollView];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</span><br><span class="line">    [<span class="keyword">self</span> magneticScrollView:scrollView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，虾米8.0首页一个视差效果简单的demo就完成了，核心代码的代码量不到100行。当然，实际的业务需求肯定没有这么简单，重要的是一种实现思路。<a href="https://github.com/tianxueweii/XiamiParallaxScrollDemo" title="https://github.com/tianxueweii/XiamiParallaxScrollDemo" target="_blank" rel="noopener">代码传送门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目迭代了一个新的版本，由于我们的设计师是虾米音乐的忠实粉丝，首页借鉴了虾米8.0首页的视差动画，在预研实现过程中有一些值得记录和分享的地方&lt;/p&gt;
&lt;h2 id=&quot;虾米音乐8-0首页鉴赏&quot;&gt;&lt;a href=&quot;#虾米音乐8-0首页鉴赏&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UINavigationBar定制的正确姿势</title>
    <link href="http://yoursite.com/2018/07/15/UINavigationBar%E5%AE%9A%E5%88%B6%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/2018/07/15/UINavigationBar定制的正确姿势/</id>
    <published>2018-07-15T12:50:58.000Z</published>
    <updated>2018-08-13T07:19:14.240Z</updated>
    
    <content type="html"><![CDATA[<p>系统导航栏（UINavigationBar）的定制一直以来都是一个比较棘手的问题，特别在iOS11以后导航栏视图结构发生了改变，导致之前很多解决方案都不再适用。由于导航栏图层独立于控制器视图，所以你可以隐藏掉导航栏使用自己绘制的导航栏仅使用导航控制器的视图栈，但本文不推荐这种方式。</p><p>本文采用的方式依然在系统导航栏的基础上进行配置。这么做的好处有很多，首先系统导航栏视图层独立于控制器视图，控制器视图加载于UINavigationTransitionView，导航栏的UINavigationBar与它是平级关系，多数情况下我们是复用它的。其次不用去自己管理复杂的视图层级关系以及滚动视图的调整行为。</p><p>导航控制器的层级关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UITransitionView</span><br><span class="line">┗ UILayoutContainerView</span><br><span class="line">┣ UINavigationTransitionView (控制器视图绘制在这个层级)</span><br><span class="line">┗ UINavigationBar</span><br></pre></td></tr></table></figure><p>导航栏的定制化可分为导航栏渲染配置、以及导航栏控件配置两个部分</p><h2 id="不同版本系统导航栏视图结构"><a href="#不同版本系统导航栏视图结构" class="headerlink" title="不同版本系统导航栏视图结构"></a>不同版本系统导航栏视图结构</h2><p>首先我们来分析一下iOS11前后导航栏（UINavigationBar）的视图结构</p><p>iOS11以前:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UINavigationBar</span><br><span class="line">┣ _UINavigationBarBackground</span><br><span class="line">┃┗ UIImageView (阴影视图)</span><br><span class="line">┣ UILabel (自定义头视图，可为任意类型)</span><br><span class="line">┣ UINavigationItemView </span><br><span class="line">┣ ...</span><br><span class="line">┗ _UINavigationBarBackIndicatorView</span><br></pre></td></tr></table></figure><p>iOS11:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UINavigationBar</span><br><span class="line">┣ _UIBarBackground</span><br><span class="line">┃┣ UIImageView (背景视图)</span><br><span class="line">┃┗ UIImageView (阴影视图)</span><br><span class="line">┗ _UINavigationBarContentView</span><br><span class="line">┣ UILabel (自定义头视图，可为任意类型)</span><br><span class="line">┣ _UIButtonBarStackView</span><br><span class="line">┃┣ _UITAMICAdaptorView</span><br><span class="line">┃┗ ...</span><br><span class="line">┗ ...</span><br></pre></td></tr></table></figure><h2 id="定制导航栏"><a href="#定制导航栏" class="headerlink" title="定制导航栏"></a>定制导航栏</h2><h3 id="UINavigationBarBackground-gt-UIBarBackground"><a href="#UINavigationBarBackground-gt-UIBarBackground" class="headerlink" title="_UINavigationBarBackground -&gt; _UIBarBackground"></a>_UINavigationBarBackground -&gt; _UIBarBackground</h3><p>通过对比，iOS11在导航栏视图上将层级更加细分。iOS11之后多了一层_UIBarBackground视图，背景图及阴影视图位于一个层级。iOS11之前设置背景图，使用<code>setBackgroundImage:forBarMetrics:</code>方法会直接作用在_UINavigationBarBackground上，iOS11之后会在_UIBarBackground下添加一个新的背景视图。但是使用<code>setBarTintColor:</code>方法，依然会着色于父层级。</p><p>通过查看系统API得知，<code>barTintColor</code>属性默认为nil，如果想要改变导航栏背景图和阴影图，我们只需要通过<code>setBackgroundImage:forBarMetrics:</code>和<code>setShadowImage:</code>两个方法即可，po上代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//设置导航栏背景视图</span></span><br><span class="line">[__navigationBar setBackgroundImage:[<span class="built_in">UIImage</span> imageWithColor:App_Background_Color] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line"><span class="comment">//去除下阴影线</span></span><br><span class="line">[__navigationBar setShadowImage:[<span class="built_in">UIImage</span> imageWithColor:[<span class="built_in">UIColor</span> clearColor] size:<span class="built_in">CGSizeMake</span>(_ScreenWidth, <span class="number">0.1</span>)]];</span><br><span class="line"><span class="comment">//渲染图标</span></span><br><span class="line">[__navigationBar setTintColor:App_NaviBar_Tint_Color];</span><br><span class="line"><span class="comment">//设置标题样式</span></span><br><span class="line">[__navigationBar setTitleTextAttributes:@&#123;</span><br><span class="line">    <span class="built_in">NSForegroundColorAttributeName</span> : App_NaviBar_Tint_Color,</span><br><span class="line">    <span class="built_in">NSFontAttributeName</span> : App_NaviBar_Text_Font</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//设置不透明</span></span><br><span class="line">[__navigationBar setTranslucent:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure><p>ps:设置想要阴影线透明，在使用<code>setShadowImage:</code>方法时，可以设置高度为0.1，若为0则有可能不生效</p><h3 id="UINavigationItemView-gt-UINavigationBarContentView"><a href="#UINavigationItemView-gt-UINavigationBarContentView" class="headerlink" title="UINavigationItemView -&gt; _UINavigationBarContentView"></a>UINavigationItemView -&gt; _UINavigationBarContentView</h3><p>内容视图的变化是导致之前设置样式失效的最大原因，iOS11所有的UIBarButtonItem都是加载到新的_UIButtonBarStackView上的，而_UIButtonBarStackView默认在5.5英寸机型有20px其余机型为16px的边距，UIBarButtonSystemItemFixedSpace也无法使用了。非常幸运，通过不断的尝试，找到了同时完美兼容多系统版本的定制化方案。UIBarButtonItem的<code>initWithCustomView:</code>方法，为我们创造了无限的可能性。</p><p>你是不是看到这里想到些什么？</p><p>我们重新造一个XXNavigationItemContainerView容器，通过<code>initWithCustomView:</code>方法加载到导航栏上，那么在XXNavigationItemContainerView视图上，我们就能做很多定制化操作了。</p><p>可能看到这里你你会觉得非常抽象，我们先看XXNavigationItemContainerView.h提供的接口以及调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">XXNavigationItemContainerView.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, XXNavigationItemContainerLocation) &#123;</span><br><span class="line">    ZMCNavigationItemContainerLocationLeft = <span class="number">0</span>, <span class="comment">//对应leftBarButtonItem</span></span><br><span class="line">    ZMCNavigationItemContainerLocationRight,    <span class="comment">//对应rightBarButtonItem</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXNavigationItemContainerView</span> : <span class="title">UIView</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) XXNavigationItemContainerLocation location;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 容器视图所包含view，view必须指定frame.size.width</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">UIView</span> *&gt;*items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 初始化导航栏Custom容器视图</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param loc 容器视图所在位置</span></span><br><span class="line"><span class="comment"> @return ins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithContainerLocation:(XXNavigationItemContainerLocation)loc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">===</span><br><span class="line"></span><br><span class="line">ViewController.m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_naviBarItemsLeftContainer = [[ZMCNavigationItemContainerView alloc] initWithContainerLocation:ZMCNavigationItemContainerLocationLeft];    </span><br><span class="line">_naviBarItemsLeftContainer.items = @[<span class="keyword">self</span>.backItem];</span><br><span class="line"><span class="keyword">self</span>.navigationItem.leftBarButtonItem = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithCustomView:_naviBarItemsLeftContainer];</span><br></pre></td></tr></table></figure><p>通过这样的方式，我们只需要向Container添加元素，Container会根据添加顺序自动渲染出视图，并通过<code>initWithCustomView:</code>接口设置到导航栏的内容视图上。</p><p>通过<code>setItems:</code>方法实现容器对元素的渲染这里就不再赘述，之前有讲过_UIButtonBarStackView在5.5英寸机型有20px其余机型为16px的边距，这里来讲讲如何解决这个问题。</p><p>根据UI视觉上的具体参数，我们可以在将元素渲染进容器时调整它的整体偏移，类似这个效果:</p><p><img src="/2018/07/15/UINavigationBar定制的正确姿势/navibar_cus_img_1.png" alt=""></p><p>我们可以使用宏或者函数的方式，获取不同机型上的偏移，并且修正它，这是很容易做到的。但是这么做以后，你会发现超出父视图部分的点击事件，无法响应了。解决这个问题就涉及了事件响应链（hit-test）相关的知识了，请自行学习，这里只讲实现和解决方案，po上代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> expectFrame;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.location) &#123;</span><br><span class="line">        <span class="keyword">case</span> XXNavigationItemContainerLocationLeft:</span><br><span class="line">            expectFrame = <span class="built_in">CGRectMake</span>(-NaviBar_Item_Offset, <span class="number">0</span>, <span class="keyword">self</span>.bounds.size.width, <span class="keyword">self</span>.bounds.size.height);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> XXNavigationItemContainerLocationRight:</span><br><span class="line">            expectFrame = <span class="built_in">CGRectMake</span>(NaviBar_Item_Offset, <span class="number">0</span>, <span class="keyword">self</span>.bounds.size.width, <span class="keyword">self</span>.bounds.size.height);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(expectFrame, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我使用<code>NaviBar_Item_Offset</code>来定义所需修正的偏移量，在触摸事件发生响应链寻找最佳匹配视图时，修正视图位置信息并将其与触摸位置进行匹配，返回结果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统导航栏（UINavigationBar）的定制一直以来都是一个比较棘手的问题，特别在iOS11以后导航栏视图结构发生了改变，导致之前很多解决方案都不再适用。由于导航栏图层独立于控制器视图，所以你可以隐藏掉导航栏使用自己绘制的导航栏仅使用导航控制器的视图栈，但本文不推荐这
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iPhoneX适配笔记</title>
    <link href="http://yoursite.com/2017/10/07/iPhoneX%E9%80%82%E9%85%8D%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/10/07/iPhoneX适配笔记/</id>
    <published>2017-10-07T09:42:46.000Z</published>
    <updated>2018-08-19T09:49:10.509Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录iPhone X适配过程中存在的一些问题，同时关注了iOS11的一些系统层面改动，可能涉及交互、视觉，目的是符合新的交互规范，界面美观友好。<br>我将按照一个项目的适配顺序来讲解</p><h2 id="Safe-Area"><a href="#Safe-Area" class="headerlink" title="Safe Area"></a>Safe Area</h2><p>iOS11提出的概念，处于Safe Area范围内的视图保证不会被遮挡，Safe Area默认尺寸如图：</p><p><img src="/2017/10/07/iPhoneX适配笔记/iphoneX适配_safeArea.png" alt="avatar"></p><p> Masonry最新版本更新了对应的API，iOS11下，可以相对于<code>safeAreaLayoutGuide...</code>进行约束</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if (__IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 110000) || (__TV_OS_VERSION_MAX_ALLOWED &gt;= 110000)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_safeAreaLayoutGuide API_AVAILABLE(ios(<span class="number">11.0</span>),tvos(<span class="number">11.0</span>));</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_safeAreaLayoutGuideTop API_AVAILABLE(ios(<span class="number">11.0</span>),tvos(<span class="number">11.0</span>));</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_safeAreaLayoutGuideBottom API_AVAILABLE(ios(<span class="number">11.0</span>),tvos(<span class="number">11.0</span>));</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_safeAreaLayoutGuideLeft API_AVAILABLE(ios(<span class="number">11.0</span>),tvos(<span class="number">11.0</span>));</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_safeAreaLayoutGuideRight API_AVAILABLE(ios(<span class="number">11.0</span>),tvos(<span class="number">11.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><blockquote><p>如果父视图处于Safe Area内，以上部约束为例，父视图的<code>mas_safeAreaLayoutGuideTop</code>与<code>mas_top</code>属性保持一致</p></blockquote><p>在iPhone 8上可能Safe Area这个概念可能比较抽象，但是在iPhone X上表现得比较明显</p><p><img src="/2017/10/07/iPhoneX适配笔记/iphoneX适配_safeArea2.png" width="30%"></p><h2 id="启动图"><a href="#启动图" class="headerlink" title="启动图"></a>启动图</h2><p>第一次运行你的APP会发现上下部缺了一部分，跟苹果每次发不同的尺寸手机时一样，你都要为她添加启动图，如图：</p><p><img src="/2017/10/07/iPhoneX适配笔记/iphoneX适配_启动图1.png" width="30%"></p><p>进去后</p><p><img src="/2017/10/07/iPhoneX适配笔记/iphoneX适配_启动图2.png" width="30%"></p><p>iPhone X的Launch图尺寸是<code>1125*2436</code></p><blockquote><p>配置代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;extent&quot; : &quot;full-screen&quot;,</span><br><span class="line">      &quot;idiom&quot; : &quot;iphone&quot;,</span><br><span class="line">      &quot;subtype&quot; : &quot;2436h&quot;,</span><br><span class="line">      &quot;filename&quot; : &quot;xxx-1125*2436@3x.png&quot;,</span><br><span class="line">      &quot;minimum-system-version&quot; : &quot;11.0&quot;,</span><br><span class="line">      &quot;orientation&quot; : &quot;portrait&quot;,</span><br><span class="line">      &quot;scale&quot; : &quot;3x&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="TabBar"><a href="#TabBar" class="headerlink" title="TabBar"></a>TabBar</h2><p>在iPhone X下，push新的控制器进入界面，tab栏会有一个高度偏移44个单位</p><p><img src="/2017/10/07/iPhoneX适配笔记/iphoneX适配_tab高度变化.png" width="30%"></p><p>目前解决方案在TabbarController添加如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLayoutSubviews &#123;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">super</span> viewDidLayoutSubviews];</span><br><span class="line">    <span class="built_in">CGFloat</span> tabbarHeight = __IS_IPHONE_X ? <span class="number">83</span> : <span class="number">49</span>; <span class="comment">// 适配iPhone x 底栏高度</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.tabBar.frame;</span><br><span class="line">    frame.size.height = tabbarHeight;</span><br><span class="line">    frame.origin.y = <span class="keyword">self</span>.view.frame.size.height - frame.size.height;</span><br><span class="line">    <span class="keyword">self</span>.tabBar.frame = frame;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避开危险区"><a href="#避开危险区" class="headerlink" title="避开危险区"></a>避开危险区</h2><p>iPhone X在顶部多出了44个像素的圆角显示状态栏，底部多出了34个像素用于home键操作，我们应该避开他们：</p><h3 id="底部工具栏"><a href="#底部工具栏" class="headerlink" title="底部工具栏"></a>底部工具栏</h3><p><img src="/2017/10/07/iPhoneX适配笔记/iphoneX适配_工具栏.png" width="30%"></p><blockquote><p>此处原方案是使用<code>safeAreaLayoutGuide</code>进行布局，但实际效果上来看并不理想，所以此处判断在iPhone X下固定高度，自外向内布局，为home留出操作空间</p></blockquote><h3 id="sheet弹框"><a href="#sheet弹框" class="headerlink" title="sheet弹框"></a>sheet弹框</h3><p>取消cell，遮挡住home键</p><p><img src="/2017/10/07/iPhoneX适配笔记/iphoneX适配_底部弹出框遮挡home.png" width="30%"></p><blockquote><p>这种样式的弹框不可避免遮挡home键，可以将控件整体提高34个像素，留出home操作空间</p></blockquote><p><img src="/2017/10/07/iPhoneX适配笔记/iphoneX适配_底部弹出框遮挡home2.png" width="30%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文简单记录iPhone X适配过程中存在的一些问题，同时关注了iOS11的一些系统层面改动，可能涉及交互、视觉，目的是符合新的交互规范，界面美观友好。&lt;br&gt;我将按照一个项目的适配顺序来讲解&lt;/p&gt;
&lt;h2 id=&quot;Safe-Area&quot;&gt;&lt;a href=&quot;#Safe-Ar
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
